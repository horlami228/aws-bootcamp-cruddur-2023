{"ast":null,"code":"import { __assign, __asyncValues, __awaiter, __generator, __read, __spread, __values } from \"tslib\";\nimport { ModelPredicateCreator as FlatModelPredicateCreator, comparisonKeys } from './index';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\nvar ops = __spread(comparisonKeys);\n/**\n * A pointer used by DataStore internally to lookup predicate details\n * that should not be exposed on public customer interfaces.\n */\nvar PredicateInternalsKey = /** @class */function () {\n  function PredicateInternalsKey() {\n    this.__isPredicateInternalsKeySentinel = true;\n  }\n  return PredicateInternalsKey;\n}();\nexport { PredicateInternalsKey };\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\nvar predicateInternalsMap = new Map();\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\nvar registerPredicateInternals = function (condition, key) {\n  var finalKey = key || new PredicateInternalsKey();\n  predicateInternalsMap.set(finalKey, condition);\n  return finalKey;\n};\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\nexport var internals = function (key) {\n  if (!predicateInternalsMap.has(key)) {\n    throw new Error(\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\");\n  }\n  return predicateInternalsMap.get(key);\n};\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\nvar negations = {\n  and: 'or',\n  or: 'and',\n  not: 'and',\n  eq: 'ne',\n  ne: 'eq',\n  gt: 'le',\n  ge: 'lt',\n  lt: 'ge',\n  le: 'gt',\n  contains: 'notContains',\n  notContains: 'contains'\n};\n/**\n * Given a V1 predicate \"seed\", applies a list of V2 field-level conditions\n * to the predicate, returning a new/final V1 predicate chain link.\n * @param predicate The base/seed V1 predicate to build on\n * @param conditions The V2 conditions to add to the predicate chain.\n * @param negateChildren Whether the conditions should be negated first.\n * @returns A V1 predicate, with conditions incorporated.\n */\nfunction applyConditionsToV1Predicate(predicate, conditions, negateChildren) {\n  var e_1, _a, e_2, _b;\n  var p = predicate;\n  var finalConditions = [];\n  try {\n    for (var conditions_1 = __values(conditions), conditions_1_1 = conditions_1.next(); !conditions_1_1.done; conditions_1_1 = conditions_1.next()) {\n      var c = conditions_1_1.value;\n      if (negateChildren) {\n        if (c.operator === 'between') {\n          finalConditions.push(new FieldCondition(c.field, 'lt', [c.operands[0]]), new FieldCondition(c.field, 'gt', [c.operands[1]]));\n        } else {\n          finalConditions.push(new FieldCondition(c.field, negations[c.operator], c.operands));\n        }\n      } else {\n        finalConditions.push(c);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (conditions_1_1 && !conditions_1_1.done && (_a = conditions_1.return)) _a.call(conditions_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  try {\n    for (var finalConditions_1 = __values(finalConditions), finalConditions_1_1 = finalConditions_1.next(); !finalConditions_1_1.done; finalConditions_1_1 = finalConditions_1.next()) {\n      var c = finalConditions_1_1.value;\n      p = p[c.field](c.operator, c.operator === 'between' ? c.operands : c.operands[0]);\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (finalConditions_1_1 && !finalConditions_1_1.done && (_b = finalConditions_1.return)) _b.call(finalConditions_1);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n  return p;\n}\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\nvar FieldCondition = /** @class */function () {\n  function FieldCondition(field, operator, operands) {\n    this.field = field;\n    this.operator = operator;\n    this.operands = operands;\n    this.validate();\n  }\n  /**\n   * Creates a copy of self.\n   * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n   * @returns A new, identitical `FieldCondition`.\n   */\n  FieldCondition.prototype.copy = function (extract) {\n    return [new FieldCondition(this.field, this.operator, __spread(this.operands)), undefined];\n  };\n  FieldCondition.prototype.toAST = function () {\n    var _a, _b;\n    return _a = {}, _a[this.field] = (_b = {}, _b[this.operator] = this.operator === 'between' ? [this.operands[0], this.operands[1]] : this.operands[0], _b), _a;\n  };\n  /**\n   * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n   * transforms them into legacy predicates. (*For now.*)\n   * @param storage N/A. If ever implemented, the storage adapter to query.\n   * @returns N/A. If ever implemented, return items from `storage` that match.\n   */\n  FieldCondition.prototype.fetch = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, Promise.reject('No implementation needed [yet].')];\n      });\n    });\n  };\n  /**\n   * Determins whether a given item matches the expressed condition.\n   * @param item The item to test.\n   * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n   */\n  FieldCondition.prototype.matches = function (item) {\n    return __awaiter(this, void 0, void 0, function () {\n      var v, operations, operation;\n      var _this = this;\n      return __generator(this, function (_a) {\n        v = String(item[this.field]);\n        operations = {\n          eq: function () {\n            return v === _this.operands[0];\n          },\n          ne: function () {\n            return v !== _this.operands[0];\n          },\n          gt: function () {\n            return v > _this.operands[0];\n          },\n          ge: function () {\n            return v >= _this.operands[0];\n          },\n          lt: function () {\n            return v < _this.operands[0];\n          },\n          le: function () {\n            return v <= _this.operands[0];\n          },\n          contains: function () {\n            return v.indexOf(_this.operands[0]) > -1;\n          },\n          notContains: function () {\n            return v.indexOf(_this.operands[0]) === -1;\n          },\n          beginsWith: function () {\n            return v.startsWith(_this.operands[0]);\n          },\n          between: function () {\n            return v >= _this.operands[0] && v <= _this.operands[1];\n          }\n        };\n        operation = operations[this.operator];\n        if (operation) {\n          return [2 /*return*/, operation()];\n        } else {\n          throw new Error(\"Invalid operator given: \" + this.operator);\n        }\n        return [2 /*return*/];\n      });\n    });\n  };\n  /**\n   * Checks `this.operands` for compatibility with `this.operator`.\n   */\n  FieldCondition.prototype.validate = function () {\n    var _this = this;\n    /**\n     * Creates a validator that checks for a particular `operands` count.\n     * Throws an exception if the `count` disagrees with `operands.length`.\n     * @param count The number of `operands` expected.\n     */\n    var argumentCount = function (count) {\n      var argsClause = count === 1 ? 'argument is' : 'arguments are';\n      return function () {\n        if (_this.operands.length !== count) {\n          return \"Exactly \" + count + \" \" + argsClause + \" required.\";\n        }\n      };\n    };\n    // NOTE: validations should return a message on failure.\n    // hence, they should be \"joined\" together with logical OR's\n    // as seen in the `between:` entry.\n    var validations = {\n      eq: argumentCount(1),\n      ne: argumentCount(1),\n      gt: argumentCount(1),\n      ge: argumentCount(1),\n      lt: argumentCount(1),\n      le: argumentCount(1),\n      contains: argumentCount(1),\n      notContains: argumentCount(1),\n      beginsWith: argumentCount(1),\n      between: function () {\n        return argumentCount(2)() || (_this.operands[0] > _this.operands[1] ? 'The first argument must be less than or equal to the second argument.' : null);\n      }\n    };\n    var validate = validations[this.operator];\n    if (validate) {\n      var e = validate();\n      if (typeof e === 'string') throw new Error(\"Incorrect usage of `\" + this.operator + \"()`: \" + e);\n    } else {\n      throw new Error(\"Non-existent operator: `\" + this.operator + \"()`\");\n    }\n  };\n  return FieldCondition;\n}();\nexport { FieldCondition };\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\nvar getGroupId = function () {\n  var seed = 1;\n  return function () {\n    return \"group_\" + seed++;\n  };\n}();\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\nvar GroupCondition = /** @class */function () {\n  function GroupCondition(\n  /**\n   * The `ModelMeta` of the model to query and/or filter against.\n   * Expected to contain:\n   *\n   * ```js\n   * {\n   * \tbuilder: ModelConstructor,\n   * \tschema: SchemaModel,\n   * \tpkField: string[]\n   * }\n   * ```\n   */\n  model,\n  /**\n   * If populated, this group specifices a condition on a relationship.\n   *\n   * If `field` does *not* point to a related model, that's an error. It\n   * could indicate that the `GroupCondition` was instantiated with bad\n   * data, or that the model metadata is incorrect.\n   */\n  field,\n  /**\n   * If a `field` is given, whether the relationship is a `HAS_ONE`,\n   * 'HAS_MANY`, or `BELONGS_TO`.\n   *\n   * TODO: Remove this and replace with derivation using\n   * `ModelRelationship.from(this.model, this.field).relationship`;\n   */\n  relationshipType,\n  /**\n   *\n   */\n  operator,\n  /**\n   *\n   */\n  operands) {\n    this.model = model;\n    this.field = field;\n    this.relationshipType = relationshipType;\n    this.operator = operator;\n    this.operands = operands;\n    // `groupId` was used for development/debugging.\n    // Should we leave this in for future troubleshooting?\n    this.groupId = getGroupId();\n  }\n  /**\n   * Returns a copy of a GroupCondition, which also returns the copy of a\n   * given reference node to \"extract\".\n   * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n   * @returns [The full copy, the copy of `extract` | undefined]\n   */\n  GroupCondition.prototype.copy = function (extract) {\n    var copied = new GroupCondition(this.model, this.field, this.relationshipType, this.operator, []);\n    var extractedCopy = extract === this ? copied : undefined;\n    this.operands.forEach(function (o) {\n      var _a = __read(o.copy(extract), 2),\n        operandCopy = _a[0],\n        extractedFromOperand = _a[1];\n      copied.operands.push(operandCopy);\n      extractedCopy = extractedCopy || extractedFromOperand;\n    });\n    return [copied, extractedCopy];\n  };\n  /**\n   * Fetches matching records from a given storage adapter using legacy predicates (for now).\n   * @param storage The storage adapter this predicate will query against.\n   * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n   * GroupdCondition.fetch is nested within.\n   * @param negate Whether to match on the `NOT` of `this`.\n   * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n   */\n  GroupCondition.prototype.fetch = function (storage, breadcrumb, negate) {\n    if (breadcrumb === void 0) {\n      breadcrumb = [];\n    }\n    if (negate === void 0) {\n      negate = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var resultGroups, operator, negateChildren, groups, conditions, groups_1, groups_1_1, g, relatives, relationship, relativesPredicates, _loop_1, relatives_1, relatives_1_1, relative, predicate, _a, _b, e_3_1, predicate, _c, _d, _e, _f, getPKValue, resultIndex, resultGroups_1, resultGroups_1_1, group, intersectWith, _g, _h, k, resultGroups_2, resultGroups_2_1, group, group_1, group_1_1, item;\n      var e_3, _j, e_4, _k, e_5, _l, e_6, _m, e_7, _o, e_8, _p;\n      var _this = this;\n      return __generator(this, function (_q) {\n        switch (_q.label) {\n          case 0:\n            resultGroups = [];\n            operator = negate ? negations[this.operator] : this.operator;\n            negateChildren = negate !== (this.operator === 'not');\n            groups = this.operands.filter(function (op) {\n              return op instanceof GroupCondition;\n            });\n            conditions = this.operands.filter(function (op) {\n              return op instanceof FieldCondition;\n            });\n            _q.label = 1;\n          case 1:\n            _q.trys.push([1, 10, 11, 12]);\n            groups_1 = __values(groups), groups_1_1 = groups_1.next();\n            _q.label = 2;\n          case 2:\n            if (!!groups_1_1.done) return [3 /*break*/, 9];\n            g = groups_1_1.value;\n            return [4 /*yield*/, g.fetch(storage, __spread(breadcrumb, [this.groupId]), negateChildren)];\n          case 3:\n            relatives = _q.sent();\n            // no relatives -> no need to attempt to perform a \"join\" query for\n            // candidate results:\n            //\n            // select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n            //\n            // Additionally, the entire (sub)-query can be short-circuited if\n            // the operator is `AND`. Illustrated in SQL:\n            //\n            // select a.* from a where\n            //   id in [a,b,c]\n            //     AND                        <\n            //   id in EMTPY_SET            <<< Look!\n            //     AND                        <\n            //   id in [x,y,z]\n            //\n            // YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n            //\n            if (relatives.length === 0) {\n              // aggressively short-circuit as soon as we know the group condition will fail\n              if (operator === 'and') {\n                return [2 /*return*/, []];\n              }\n              // less aggressive short-circuit if we know the relatives will produce no\n              // candidate results; but aren't sure yet how this affects the group condition.\n              resultGroups.push([]);\n              return [3 /*break*/, 8];\n            }\n            if (!g.field) return [3 /*break*/, 7];\n            relationship = ModelRelationship.from(this.model, g.field);\n            if (!relationship) return [3 /*break*/, 5];\n            relativesPredicates = [];\n            _loop_1 = function (relative) {\n              var individualRowJoinConditions = [];\n              for (var i = 0; i < relationship.localJoinFields.length; i++) {\n                // rightHandValue\n                individualRowJoinConditions.push(new FieldCondition(relationship.localJoinFields[i], 'eq', [relative[relationship.remoteJoinFields[i]]]));\n              }\n              var predicate_1 = function (p) {\n                return applyConditionsToV1Predicate(p, individualRowJoinConditions, false);\n              };\n              relativesPredicates.push(predicate_1);\n            };\n            try {\n              for (relatives_1 = (e_4 = void 0, __values(relatives)), relatives_1_1 = relatives_1.next(); !relatives_1_1.done; relatives_1_1 = relatives_1.next()) {\n                relative = relatives_1_1.value;\n                _loop_1(relative);\n              }\n            } catch (e_4_1) {\n              e_4 = {\n                error: e_4_1\n              };\n            } finally {\n              try {\n                if (relatives_1_1 && !relatives_1_1.done && (_k = relatives_1.return)) _k.call(relatives_1);\n              } finally {\n                if (e_4) throw e_4.error;\n              }\n            }\n            predicate = FlatModelPredicateCreator.createGroupFromExisting(this.model.schema, 'or', relativesPredicates);\n            _b = (_a = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder, predicate)];\n          case 4:\n            _b.apply(_a, [_q.sent()]);\n            return [3 /*break*/, 6];\n          case 5:\n            throw new Error('Missing field metadata.');\n          case 6:\n            return [3 /*break*/, 8];\n          case 7:\n            // relatives are not actually relatives. they're candidate results.\n            resultGroups.push(relatives);\n            _q.label = 8;\n          case 8:\n            groups_1_1 = groups_1.next();\n            return [3 /*break*/, 2];\n          case 9:\n            return [3 /*break*/, 12];\n          case 10:\n            e_3_1 = _q.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3 /*break*/, 12];\n          case 11:\n            try {\n              if (groups_1_1 && !groups_1_1.done && (_j = groups_1.return)) _j.call(groups_1);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n            return [7 /*endfinally*/];\n          case 12:\n            if (!(conditions.length > 0)) return [3 /*break*/, 14];\n            predicate = FlatModelPredicateCreator.createFromExisting(this.model.schema, function (p) {\n              return p[operator](function (c) {\n                return applyConditionsToV1Predicate(c, conditions, negateChildren);\n              });\n            });\n            _d = (_c = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder, predicate)];\n          case 13:\n            _d.apply(_c, [_q.sent()]);\n            return [3 /*break*/, 16];\n          case 14:\n            if (!(conditions.length === 0 && resultGroups.length === 0)) return [3 /*break*/, 16];\n            _f = (_e = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder)];\n          case 15:\n            _f.apply(_e, [_q.sent()]);\n            _q.label = 16;\n          case 16:\n            getPKValue = function (item) {\n              return JSON.stringify(_this.model.pkField.map(function (name) {\n                return item[name];\n              }));\n            };\n            if (operator === 'and') {\n              if (resultGroups.length === 0) {\n                return [2 /*return*/, []];\n              }\n              try {\n                // for each group, we intersect, removing items from the result index\n                // that aren't present in each subsequent group.\n                for (resultGroups_1 = __values(resultGroups), resultGroups_1_1 = resultGroups_1.next(); !resultGroups_1_1.done; resultGroups_1_1 = resultGroups_1.next()) {\n                  group = resultGroups_1_1.value;\n                  if (resultIndex === undefined) {\n                    resultIndex = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n                  } else {\n                    intersectWith = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n                    try {\n                      for (_g = (e_6 = void 0, __values(resultIndex.keys())), _h = _g.next(); !_h.done; _h = _g.next()) {\n                        k = _h.value;\n                        if (!intersectWith.has(k)) {\n                          resultIndex.delete(k);\n                        }\n                      }\n                    } catch (e_6_1) {\n                      e_6 = {\n                        error: e_6_1\n                      };\n                    } finally {\n                      try {\n                        if (_h && !_h.done && (_m = _g.return)) _m.call(_g);\n                      } finally {\n                        if (e_6) throw e_6.error;\n                      }\n                    }\n                  }\n                }\n              } catch (e_5_1) {\n                e_5 = {\n                  error: e_5_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_1_1 && !resultGroups_1_1.done && (_l = resultGroups_1.return)) _l.call(resultGroups_1);\n                } finally {\n                  if (e_5) throw e_5.error;\n                }\n              }\n            } else if (operator === 'or' || operator === 'not') {\n              // it's OK to handle NOT here, because NOT must always only negate\n              // a single child predicate. NOT logic will have been distributed down\n              // to the leaf conditions already.\n              resultIndex = new Map();\n              try {\n                // just merge the groups, performing DISTINCT-ification by ID.\n                for (resultGroups_2 = __values(resultGroups), resultGroups_2_1 = resultGroups_2.next(); !resultGroups_2_1.done; resultGroups_2_1 = resultGroups_2.next()) {\n                  group = resultGroups_2_1.value;\n                  try {\n                    for (group_1 = (e_8 = void 0, __values(group)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {\n                      item = group_1_1.value;\n                      resultIndex.set(getPKValue(item), item);\n                    }\n                  } catch (e_8_1) {\n                    e_8 = {\n                      error: e_8_1\n                    };\n                  } finally {\n                    try {\n                      if (group_1_1 && !group_1_1.done && (_p = group_1.return)) _p.call(group_1);\n                    } finally {\n                      if (e_8) throw e_8.error;\n                    }\n                  }\n                }\n              } catch (e_7_1) {\n                e_7 = {\n                  error: e_7_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_2_1 && !resultGroups_2_1.done && (_o = resultGroups_2.return)) _o.call(resultGroups_2);\n                } finally {\n                  if (e_7) throw e_7.error;\n                }\n              }\n            }\n            return [2 /*return*/, Array.from((resultIndex === null || resultIndex === void 0 ? void 0 : resultIndex.values()) || [])];\n        }\n      });\n    });\n  };\n  /**\n   * Determines whether a single item matches the conditions of `this`.\n   * When checking the target `item`'s properties, each property will be `await`'d\n   * to ensure lazy-loading is respected where applicable.\n   * @param item The item to match against.\n   * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n   * (Used for iterating over children on HAS_MANY checks.)\n   * @returns A boolean (promise): `true` if matched, `false` otherwise.\n   */\n  GroupCondition.prototype.matches = function (item, ignoreFieldName) {\n    if (ignoreFieldName === void 0) {\n      ignoreFieldName = false;\n    }\n    var e_9, _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var itemToCheck, _b, itemToCheck_1, itemToCheck_1_1, singleItem, e_9_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(this.field && !ignoreFieldName)) return [3 /*break*/, 2];\n            return [4 /*yield*/, item[this.field]];\n          case 1:\n            _b = _c.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            _b = item;\n            _c.label = 3;\n          case 3:\n            itemToCheck = _b;\n            // if there is no item to check, we can stop recursing immediately.\n            // a condition cannot match against an item that does not exist. this\n            // can occur when `item.field` is optional in the schema.\n            if (!itemToCheck) {\n              return [2 /*return*/, false];\n            }\n            if (!(this.relationshipType === 'HAS_MANY' && typeof itemToCheck[Symbol.asyncIterator] === 'function')) return [3 /*break*/, 17];\n            _c.label = 4;\n          case 4:\n            _c.trys.push([4, 10, 11, 16]);\n            itemToCheck_1 = __asyncValues(itemToCheck);\n            _c.label = 5;\n          case 5:\n            return [4 /*yield*/, itemToCheck_1.next()];\n          case 6:\n            if (!(itemToCheck_1_1 = _c.sent(), !itemToCheck_1_1.done)) return [3 /*break*/, 9];\n            singleItem = itemToCheck_1_1.value;\n            return [4 /*yield*/, this.matches(singleItem, true)];\n          case 7:\n            if (_c.sent()) {\n              return [2 /*return*/, true];\n            }\n            _c.label = 8;\n          case 8:\n            return [3 /*break*/, 5];\n          case 9:\n            return [3 /*break*/, 16];\n          case 10:\n            e_9_1 = _c.sent();\n            e_9 = {\n              error: e_9_1\n            };\n            return [3 /*break*/, 16];\n          case 11:\n            _c.trys.push([11,, 14, 15]);\n            if (!(itemToCheck_1_1 && !itemToCheck_1_1.done && (_a = itemToCheck_1.return))) return [3 /*break*/, 13];\n            return [4 /*yield*/, _a.call(itemToCheck_1)];\n          case 12:\n            _c.sent();\n            _c.label = 13;\n          case 13:\n            return [3 /*break*/, 15];\n          case 14:\n            if (e_9) throw e_9.error;\n            return [7 /*endfinally*/];\n          case 15:\n            return [7 /*endfinally*/];\n          case 16:\n            return [2 /*return*/, false];\n          case 17:\n            if (!(this.operator === 'or')) return [3 /*break*/, 18];\n            return [2 /*return*/, asyncSome(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n          case 18:\n            if (!(this.operator === 'and')) return [3 /*break*/, 19];\n            return [2 /*return*/, asyncEvery(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n          case 19:\n            if (!(this.operator === 'not')) return [3 /*break*/, 21];\n            if (this.operands.length !== 1) {\n              throw new Error('Invalid arguments! `not()` accepts exactly one predicate expression.');\n            }\n            return [4 /*yield*/, this.operands[0].matches(itemToCheck)];\n          case 20:\n            return [2 /*return*/, !_c.sent()];\n          case 21:\n            throw new Error('Invalid group operator!');\n        }\n      });\n    });\n  };\n  /**\n   * Tranfsorm to a AppSync GraphQL compatible AST.\n   * (Does not support filtering in nested types.)\n   */\n  GroupCondition.prototype.toAST = function () {\n    var _a;\n    if (this.field) throw new Error('Nested type conditions are not supported!');\n    return _a = {}, _a[this.operator] = this.operands.map(function (operand) {\n      return operand.toAST();\n    }), _a;\n  };\n  GroupCondition.prototype.toStoragePredicate = function (baseCondition) {\n    return FlatModelPredicateCreator.createFromAST(this.model.schema, this.toAST());\n  };\n  return GroupCondition;\n}();\nexport { GroupCondition };\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * TODO: the sortof-immutable algorithm was originally done to support legacy style\n * predicate branching (`p => p.x.eq(value).y.eq(value)`). i'm not sure this is\n * necessary or beneficial at this point, since we decided that each field condition\n * must flly terminate a branch. is the strong mutation barrier between chain links\n * still necessary or helpful?\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\nexport function recursivePredicateFor(ModelType, allowRecursion, field, query, tail) {\n  if (allowRecursion === void 0) {\n    allowRecursion = true;\n  }\n  // to be used if we don't have a base query or tail to build onto\n  var starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n  var baseCondition = query && tail ? query : starter;\n  var tailCondition = query && tail ? tail : starter;\n  // our eventual return object, which can be built upon.\n  // next steps will be to add or(), and(), not(), and field.op() methods.\n  var link = {};\n  registerPredicateInternals(baseCondition, link);\n  var copyLink = function () {\n    var _a = __read(baseCondition.copy(tailCondition), 2),\n      query = _a[0],\n      newTail = _a[1];\n    var newLink = recursivePredicateFor(ModelType, allowRecursion, undefined, query, newTail);\n    return {\n      query: query,\n      newTail: newTail,\n      newLink: newLink\n    };\n  };\n  // Adds .or() and .and() methods to the link.\n  // TODO: If revisiting this code, consider writing a Proxy instead.\n  ['and', 'or'].forEach(function (op) {\n    link[op] = function (builder) {\n      // or() and and() will return a copy of the original link\n      // to head off mutability concerns.\n      var _a = copyLink(),\n        query = _a.query,\n        newTail = _a.newTail;\n      var childConditions = builder(recursivePredicateFor(ModelType, allowRecursion));\n      if (!Array.isArray(childConditions)) {\n        throw new Error(\"Invalid predicate. `\" + op + \"` groups must return an array of child conditions.\");\n      }\n      // the customer will supply a child predicate, which apply to the `model.field`\n      // of the tail GroupCondition.\n      newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, op, childConditions.map(function (c) {\n        return internals(c);\n      })));\n      // FinalPredicate\n      return registerPredicateInternals(query);\n    };\n  });\n  // TODO: If revisiting this code, consider proxy.\n  link.not = function (builder) {\n    // not() will return a copy of the original link\n    // to head off mutability concerns.\n    var _a = copyLink(),\n      query = _a.query,\n      newTail = _a.newTail;\n    // unlike and() and or(), the customer will supply a \"singular\" child predicate.\n    // the difference being: not() does not accept an array of predicate-like objects.\n    // it negates only a *single* predicate subtree.\n    newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, 'not', [internals(builder(recursivePredicateFor(ModelType, allowRecursion)))]));\n    // A `FinalModelPredicate`.\n    // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n    // or query storage: `.__query.fetch(storage)`.\n    return registerPredicateInternals(query);\n  };\n  var _loop_2 = function (fieldName) {\n    Object.defineProperty(link, fieldName, {\n      enumerable: true,\n      get: function () {\n        var def = ModelType.schema.fields[fieldName];\n        if (!def.association) {\n          // we're looking at a value field. we need to return a\n          // \"field matcher object\", which contains all of the comparison\n          // functions ('eq', 'ne', 'gt', etc.), scoped to operate\n          // against the target field (fieldName).\n          return ops.reduce(function (fieldMatcher, operator) {\n            var _a;\n            return __assign(__assign({}, fieldMatcher), (_a = {}, _a[operator] = function () {\n              var operands = [];\n              for (var _i = 0; _i < arguments.length; _i++) {\n                operands[_i] = arguments[_i];\n              }\n              // build off a fresh copy of the existing `link`, just in case\n              // the same link is being used elsewhere by the customer.\n              var _a = copyLink(),\n                query = _a.query,\n                newTail = _a.newTail;\n              // add the given condition to the link's TAIL node.\n              // remember: the base link might go N nodes deep! e.g.,\n              newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new FieldCondition(fieldName, operator, operands));\n              // A `FinalModelPredicate`.\n              // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n              // or query storage: `.__query.fetch(storage)`.\n              return registerPredicateInternals(query);\n            }, _a));\n          }, {});\n        } else {\n          if (!allowRecursion) {\n            throw new Error('Predication on releated models is not supported in this context.');\n          } else if (def.association.connectionType === 'BELONGS_TO' || def.association.connectionType === 'HAS_ONE' || def.association.connectionType === 'HAS_MANY') {\n            // the use has just typed '.someRelatedModel'. we need to given them\n            // back a predicate chain.\n            var relatedMeta = def.type.modelConstructor;\n            if (!relatedMeta) {\n              throw new Error('Related model metadata is missing. This is a bug! Please report it.');\n            }\n            // `Model.reletedModelField` returns a copy of the original link,\n            // and will contains copies of internal GroupConditions\n            // to head off mutability concerns.\n            var _a = __read(baseCondition.copy(tailCondition), 2),\n              newquery = _a[0],\n              oldtail = _a[1];\n            var newtail = new GroupCondition(relatedMeta, fieldName, def.association.connectionType, 'and', []);\n            // `oldtail` here refers to the *copy* of the old tail.\n            // so, it's safe to modify at this point. and we need to modify\n            // it to push the *new* tail onto the end of it.\n            oldtail.operands.push(newtail);\n            var newlink = recursivePredicateFor(relatedMeta, allowRecursion, undefined, newquery, newtail);\n            return newlink;\n          } else {\n            throw new Error(\"Related model definition doesn't have a typedef. This is a bug! Please report it.\");\n          }\n        }\n      }\n    });\n  };\n  // For each field on the model schema, we want to add a getter\n  // that creates the appropriate new `link` in the query chain.\n  // TODO: If revisiting, consider a proxy.\n  for (var fieldName in ModelType.schema.fields) {\n    _loop_2(fieldName);\n  }\n  return link;\n}\nexport function predicateFor(ModelType) {\n  return recursivePredicateFor(ModelType, false);\n}","map":{"version":3,"mappings":"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","names":["ModelPredicateCreator","FlatModelPredicateCreator","comparisonKeys","ModelRelationship","asyncSome","asyncEvery","ops","__spread","predicateInternalsMap","Map","registerPredicateInternals","condition","key","finalKey","PredicateInternalsKey","set","internals","has","Error","get","negations","and","or","not","eq","ne","gt","ge","lt","le","contains","notContains","applyConditionsToV1Predicate","predicate","conditions","negateChildren","p","finalConditions","c","operator","push","FieldCondition","field","operands","validate","extract","undefined","_a","_b","storage","Promise","reject","item","v","String","operations","_this","indexOf","beginsWith","startsWith","between","operation","argumentCount","argsClause","count","length","validations","e","getGroupId","seed","model","relationshipType","GroupCondition","copied","extractedCopy","forEach","operandCopy","extractedFromOperand","breadcrumb","negate","resultGroups","groups","filter","groups_1","g","fetch","groupId","relatives","_q","relationship","from","relativesPredicates","relative","individualRowJoinConditions","i","localJoinFields","remoteJoinFields","predicate_1","relatives_1","createGroupFromExisting","schema","query","builder","createFromExisting","_d","_f","getPKValue","stringify","pkField","map","name","resultGroups_1","group","resultIndex","intersectWith","_g","keys","k","delete","resultGroups_2","group_1","Array","values","ignoreFieldName","itemToCheck","Symbol","asyncIterator","itemToCheck_1","singleItem","matches","_c","toAST","baseCondition","createFromAST","recursivePredicateFor","ModelType","allowRecursion","tail","starter","tailCondition","link","copyLink","newTail","newLink","op","childConditions","isArray","fieldName","Object","defineProperty","enumerable","def","fields","association","reduce","fieldMatcher","_i","connectionType","relatedMeta","type","modelConstructor","newquery","oldtail","newtail","newlink","predicateFor"],"sources":["/frontend-react-js/node_modules/@aws-amplify/datastore/src/predicates/next.ts"],"sourcesContent":["import {\n\tScalar,\n\tPersistentModel,\n\tModelFieldType,\n\tModelMeta,\n\tAllOperators,\n\tPredicateFieldType,\n\tModelPredicate as StoragePredicate,\n} from '../types';\n\nimport {\n\tModelPredicateCreator as FlatModelPredicateCreator,\n\tcomparisonKeys,\n} from './index';\nimport { ExclusiveStorage as StorageAdapter } from '../storage/storage';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\n\ntype MatchableTypes =\n\t| string\n\t| string[]\n\t| number\n\t| number[]\n\t| boolean\n\t| boolean[];\n\ntype AllFieldOperators = keyof AllOperators;\n\nconst ops = [...comparisonKeys] as AllFieldOperators[];\n\ntype NonNeverKeys<T> = {\n\t[K in keyof T]: T[K] extends never ? never : K;\n}[keyof T];\n\ntype WithoutNevers<T> = Pick<T, NonNeverKeys<T>>;\n\n/**\n * A function that accepts a RecursiveModelPrecicate<T>, which it must use to\n * return a final condition.\n *\n * This is used in `DataStore.query()`, `DataStore.observe()`, and\n * `DataStore.observeQuery()` as the second argument. E.g.,\n *\n * ```\n * DataStore.query(MyModel, model => model.field.eq('some value'))\n * ```\n *\n * More complex queries should also be supported. E.g.,\n *\n * ```\n * DataStore.query(MyModel, model => model.and(m => [\n *   m.relatedEntity.or(relative => [\n *     relative.relativeField.eq('whatever'),\n *     relative.relativeField.eq('whatever else')\n *   ]),\n *   m.myModelField.ne('something')\n * ]))\n * ```\n */\nexport type RecursiveModelPredicateExtender<RT extends PersistentModel> = (\n\tlambda: RecursiveModelPredicate<RT>\n) => PredicateInternalsKey;\n\nexport type RecursiveModelPredicateAggregateExtender<\n\tRT extends PersistentModel\n> = (lambda: RecursiveModelPredicate<RT>) => PredicateInternalsKey[];\n\ntype RecursiveModelPredicateOperator<RT extends PersistentModel> = (\n\tpredicates: RecursiveModelPredicateAggregateExtender<RT>\n) => PredicateInternalsKey;\n\ntype RecursiveModelPredicateNegation<RT extends PersistentModel> = (\n\tpredicate: RecursiveModelPredicateExtender<RT>\n) => PredicateInternalsKey;\n\nexport type RecursiveModelPredicate<RT extends PersistentModel> = {\n\t[K in keyof RT]-?: PredicateFieldType<RT[K]> extends PersistentModel\n\t\t? RecursiveModelPredicate<PredicateFieldType<RT[K]>>\n\t\t: ValuePredicate<RT, RT[K]>;\n} & {\n\tor: RecursiveModelPredicateOperator<RT>;\n\tand: RecursiveModelPredicateOperator<RT>;\n\tnot: RecursiveModelPredicateNegation<RT>;\n} & PredicateInternalsKey;\n\n/**\n * A function that accepts a ModelPrecicate<T>, which it must use to return a\n * final condition.\n *\n * This is used as predicates in `DataStore.save()`, `DataStore.delete()`, and\n * DataStore sync expressions.\n *\n * ```\n * DataStore.save(record, model => model.field.eq('some value'))\n * ```\n *\n * Logical operators are supported. But, condtiions are related records are\n * NOT supported. E.g.,\n *\n * ```\n * DataStore.delete(record, model => model.or(m => [\n * \tm.field.eq('whatever'),\n * \tm.field.eq('whatever else')\n * ]))\n * ```\n */\nexport type ModelPredicateExtender<RT extends PersistentModel> = (\n\tlambda: ModelPredicate<RT>\n) => PredicateInternalsKey;\n\nexport type ModelPredicateAggregateExtender<RT extends PersistentModel> = (\n\tlambda: ModelPredicate<RT>\n) => PredicateInternalsKey[];\n\ntype ValuePredicate<RT extends PersistentModel, MT extends MatchableTypes> = {\n\t[K in AllFieldOperators]: K extends 'between'\n\t\t? (\n\t\t\t\tinclusiveLowerBound: Scalar<MT>,\n\t\t\t\tinclusiveUpperBound: Scalar<MT>\n\t\t  ) => PredicateInternalsKey\n\t\t: (operand: Scalar<MT>) => PredicateInternalsKey;\n};\n\nexport type ModelPredicate<RT extends PersistentModel> = WithoutNevers<{\n\t[K in keyof RT]-?: PredicateFieldType<RT[K]> extends PersistentModel\n\t\t? never\n\t\t: ValuePredicate<RT, RT[K]>;\n}> & {\n\tor: ModelPredicateOperator<RT>;\n\tand: ModelPredicateOperator<RT>;\n\tnot: ModelPredicateNegation<RT>;\n} & PredicateInternalsKey;\n\ntype ModelPredicateOperator<RT extends PersistentModel> = (\n\tpredicates: ModelPredicateAggregateExtender<RT>\n) => PredicateInternalsKey;\n\ntype ModelPredicateNegation<RT extends PersistentModel> = (\n\tpredicate: ModelPredicateExtender<RT>\n) => PredicateInternalsKey;\n\ntype GroupOperator = 'and' | 'or' | 'not';\n\ntype UntypedCondition = {\n\tfetch: (storage: StorageAdapter) => Promise<Record<string, any>[]>;\n\tmatches: (item: Record<string, any>) => Promise<boolean>;\n\tcopy(extract: GroupCondition): [UntypedCondition, GroupCondition | undefined];\n\ttoAST(): any;\n};\n\n/**\n * A pointer used by DataStore internally to lookup predicate details\n * that should not be exposed on public customer interfaces.\n */\nexport class PredicateInternalsKey {\n\tprivate __isPredicateInternalsKeySentinel: boolean = true;\n}\n\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\nconst predicateInternalsMap = new Map<PredicateInternalsKey, GroupCondition>();\n\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\nconst registerPredicateInternals = (condition: GroupCondition, key?: any) => {\n\tconst finalKey = key || new PredicateInternalsKey();\n\tpredicateInternalsMap.set(finalKey, condition);\n\treturn finalKey;\n};\n\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\nexport const internals = (key: any) => {\n\tif (!predicateInternalsMap.has(key)) {\n\t\tthrow new Error(\n\t\t\t\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\"\n\t\t);\n\t}\n\treturn predicateInternalsMap.get(key)!;\n};\n\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\nconst negations = {\n\tand: 'or',\n\tor: 'and',\n\tnot: 'and',\n\teq: 'ne',\n\tne: 'eq',\n\tgt: 'le',\n\tge: 'lt',\n\tlt: 'ge',\n\tle: 'gt',\n\tcontains: 'notContains',\n\tnotContains: 'contains',\n};\n\n/**\n * Given a V1 predicate \"seed\", applies a list of V2 field-level conditions\n * to the predicate, returning a new/final V1 predicate chain link.\n * @param predicate The base/seed V1 predicate to build on\n * @param conditions The V2 conditions to add to the predicate chain.\n * @param negateChildren Whether the conditions should be negated first.\n * @returns A V1 predicate, with conditions incorporated.\n */\nfunction applyConditionsToV1Predicate<T>(\n\tpredicate: T,\n\tconditions: FieldCondition[],\n\tnegateChildren: boolean\n): T {\n\tlet p = predicate;\n\tconst finalConditions: FieldCondition[] = [];\n\n\tfor (const c of conditions) {\n\t\tif (negateChildren) {\n\t\t\tif (c.operator === 'between') {\n\t\t\t\tfinalConditions.push(\n\t\t\t\t\tnew FieldCondition(c.field, 'lt', [c.operands[0]]),\n\t\t\t\t\tnew FieldCondition(c.field, 'gt', [c.operands[1]])\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfinalConditions.push(\n\t\t\t\t\tnew FieldCondition(c.field, negations[c.operator], c.operands)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tfinalConditions.push(c);\n\t\t}\n\t}\n\n\tfor (const c of finalConditions) {\n\t\tp = p[c.field](\n\t\t\tc.operator as never,\n\t\t\t(c.operator === 'between' ? c.operands : c.operands[0]) as never\n\t\t);\n\t}\n\treturn p;\n}\n\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\nexport class FieldCondition {\n\tconstructor(\n\t\tpublic field: string,\n\t\tpublic operator: string,\n\t\tpublic operands: string[]\n\t) {\n\t\tthis.validate();\n\t}\n\n\t/**\n\t * Creates a copy of self.\n\t * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n\t * @returns A new, identitical `FieldCondition`.\n\t */\n\tcopy(extract: GroupCondition): [FieldCondition, GroupCondition | undefined] {\n\t\treturn [\n\t\t\tnew FieldCondition(this.field, this.operator, [...this.operands]),\n\t\t\tundefined,\n\t\t];\n\t}\n\n\ttoAST() {\n\t\treturn {\n\t\t\t[this.field]: {\n\t\t\t\t[this.operator]:\n\t\t\t\t\tthis.operator === 'between'\n\t\t\t\t\t\t? [this.operands[0], this.operands[1]]\n\t\t\t\t\t\t: this.operands[0],\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n\t * transforms them into legacy predicates. (*For now.*)\n\t * @param storage N/A. If ever implemented, the storage adapter to query.\n\t * @returns N/A. If ever implemented, return items from `storage` that match.\n\t */\n\tasync fetch(storage: StorageAdapter): Promise<Record<string, any>[]> {\n\t\treturn Promise.reject('No implementation needed [yet].');\n\t}\n\n\t/**\n\t * Determins whether a given item matches the expressed condition.\n\t * @param item The item to test.\n\t * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n\t */\n\tasync matches(item: Record<string, any>): Promise<boolean> {\n\t\tconst v = String(item[this.field]);\n\t\tconst operations = {\n\t\t\teq: () => v === this.operands[0],\n\t\t\tne: () => v !== this.operands[0],\n\t\t\tgt: () => v > this.operands[0],\n\t\t\tge: () => v >= this.operands[0],\n\t\t\tlt: () => v < this.operands[0],\n\t\t\tle: () => v <= this.operands[0],\n\t\t\tcontains: () => v.indexOf(this.operands[0]) > -1,\n\t\t\tnotContains: () => v.indexOf(this.operands[0]) === -1,\n\t\t\tbeginsWith: () => v.startsWith(this.operands[0]),\n\t\t\tbetween: () => v >= this.operands[0] && v <= this.operands[1],\n\t\t};\n\t\tconst operation = operations[this.operator as keyof typeof operations];\n\t\tif (operation) {\n\t\t\treturn operation();\n\t\t} else {\n\t\t\tthrow new Error(`Invalid operator given: ${this.operator}`);\n\t\t}\n\t}\n\n\t/**\n\t * Checks `this.operands` for compatibility with `this.operator`.\n\t */\n\tvalidate(): void {\n\t\t/**\n\t\t * Creates a validator that checks for a particular `operands` count.\n\t\t * Throws an exception if the `count` disagrees with `operands.length`.\n\t\t * @param count The number of `operands` expected.\n\t\t */\n\t\tconst argumentCount = count => {\n\t\t\tconst argsClause = count === 1 ? 'argument is' : 'arguments are';\n\t\t\treturn () => {\n\t\t\t\tif (this.operands.length !== count) {\n\t\t\t\t\treturn `Exactly ${count} ${argsClause} required.`;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\t// NOTE: validations should return a message on failure.\n\t\t// hence, they should be \"joined\" together with logical OR's\n\t\t// as seen in the `between:` entry.\n\t\tconst validations = {\n\t\t\teq: argumentCount(1),\n\t\t\tne: argumentCount(1),\n\t\t\tgt: argumentCount(1),\n\t\t\tge: argumentCount(1),\n\t\t\tlt: argumentCount(1),\n\t\t\tle: argumentCount(1),\n\t\t\tcontains: argumentCount(1),\n\t\t\tnotContains: argumentCount(1),\n\t\t\tbeginsWith: argumentCount(1),\n\t\t\tbetween: () =>\n\t\t\t\targumentCount(2)() ||\n\t\t\t\t(this.operands[0] > this.operands[1]\n\t\t\t\t\t? 'The first argument must be less than or equal to the second argument.'\n\t\t\t\t\t: null),\n\t\t};\n\t\tconst validate = validations[this.operator as keyof typeof validations];\n\t\tif (validate) {\n\t\t\tconst e = validate();\n\t\t\tif (typeof e === 'string')\n\t\t\t\tthrow new Error(`Incorrect usage of \\`${this.operator}()\\`: ${e}`);\n\t\t} else {\n\t\t\tthrow new Error(`Non-existent operator: \\`${this.operator}()\\``);\n\t\t}\n\t}\n}\n\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\nconst getGroupId = (() => {\n\tlet seed = 1;\n\treturn () => `group_${seed++}`;\n})();\n\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\nexport class GroupCondition {\n\t// `groupId` was used for development/debugging.\n\t// Should we leave this in for future troubleshooting?\n\tpublic groupId = getGroupId();\n\n\tconstructor(\n\t\t/**\n\t\t * The `ModelMeta` of the model to query and/or filter against.\n\t\t * Expected to contain:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t * \tbuilder: ModelConstructor,\n\t\t * \tschema: SchemaModel,\n\t\t * \tpkField: string[]\n\t\t * }\n\t\t * ```\n\t\t */\n\t\tpublic model: ModelMeta<any>,\n\n\t\t/**\n\t\t * If populated, this group specifices a condition on a relationship.\n\t\t *\n\t\t * If `field` does *not* point to a related model, that's an error. It\n\t\t * could indicate that the `GroupCondition` was instantiated with bad\n\t\t * data, or that the model metadata is incorrect.\n\t\t */\n\t\tpublic field: string | undefined,\n\n\t\t/**\n\t\t * If a `field` is given, whether the relationship is a `HAS_ONE`,\n\t\t * 'HAS_MANY`, or `BELONGS_TO`.\n\t\t *\n\t\t * TODO: Remove this and replace with derivation using\n\t\t * `ModelRelationship.from(this.model, this.field).relationship`;\n\t\t */\n\t\tpublic relationshipType: string | undefined,\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic operator: GroupOperator,\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic operands: UntypedCondition[]\n\t) {}\n\n\t/**\n\t * Returns a copy of a GroupCondition, which also returns the copy of a\n\t * given reference node to \"extract\".\n\t * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n\t * @returns [The full copy, the copy of `extract` | undefined]\n\t */\n\tcopy(extract: GroupCondition): [GroupCondition, GroupCondition | undefined] {\n\t\tconst copied = new GroupCondition(\n\t\t\tthis.model,\n\t\t\tthis.field,\n\t\t\tthis.relationshipType,\n\t\t\tthis.operator,\n\t\t\t[]\n\t\t);\n\n\t\tlet extractedCopy: GroupCondition | undefined =\n\t\t\textract === this ? copied : undefined;\n\n\t\tthis.operands.forEach(o => {\n\t\t\tconst [operandCopy, extractedFromOperand] = o.copy(extract);\n\t\t\tcopied.operands.push(operandCopy);\n\t\t\textractedCopy = extractedCopy || extractedFromOperand;\n\t\t});\n\n\t\treturn [copied, extractedCopy];\n\t}\n\n\t/**\n\t * Fetches matching records from a given storage adapter using legacy predicates (for now).\n\t * @param storage The storage adapter this predicate will query against.\n\t * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n\t * GroupdCondition.fetch is nested within.\n\t * @param negate Whether to match on the `NOT` of `this`.\n\t * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n\t */\n\tasync fetch(\n\t\tstorage: StorageAdapter,\n\t\tbreadcrumb: string[] = [],\n\t\tnegate = false\n\t): Promise<Record<string, any>[]> {\n\t\tconst resultGroups: Array<Record<string, any>[]> = [];\n\n\t\tconst operator = (negate ? negations[this.operator] : this.operator) as\n\t\t\t| 'or'\n\t\t\t| 'and'\n\t\t\t| 'not';\n\n\t\tconst negateChildren = negate !== (this.operator === 'not');\n\n\t\t/**\n\t\t * Conditions that must be branched out and used to generate a base, \"candidate\"\n\t\t * result set.\n\t\t *\n\t\t * If `field` is populated, these groups select *related* records, and the base,\n\t\t * candidate results are selected to match those.\n\t\t */\n\t\tconst groups = this.operands.filter(\n\t\t\top => op instanceof GroupCondition\n\t\t) as GroupCondition[];\n\n\t\t/**\n\t\t * Simple conditions that must match the target model of `this`.\n\t\t */\n\t\tconst conditions = this.operands.filter(\n\t\t\top => op instanceof FieldCondition\n\t\t) as FieldCondition[];\n\n\t\tfor (const g of groups) {\n\t\t\tconst relatives = await g.fetch(\n\t\t\t\tstorage,\n\t\t\t\t[...breadcrumb, this.groupId],\n\t\t\t\tnegateChildren\n\t\t\t);\n\n\t\t\t// no relatives -> no need to attempt to perform a \"join\" query for\n\t\t\t// candidate results:\n\t\t\t//\n\t\t\t// select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n\t\t\t//\n\t\t\t// Additionally, the entire (sub)-query can be short-circuited if\n\t\t\t// the operator is `AND`. Illustrated in SQL:\n\t\t\t//\n\t\t\t// select a.* from a where\n\t\t\t//   id in [a,b,c]\n\t\t\t//     AND                        <\n\t\t\t//   id in EMTPY_SET            <<< Look!\n\t\t\t//     AND                        <\n\t\t\t//   id in [x,y,z]\n\t\t\t//\n\t\t\t// YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n\t\t\t//\n\t\t\tif (relatives.length === 0) {\n\t\t\t\t// aggressively short-circuit as soon as we know the group condition will fail\n\t\t\t\tif (operator === 'and') {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\t// less aggressive short-circuit if we know the relatives will produce no\n\t\t\t\t// candidate results; but aren't sure yet how this affects the group condition.\n\t\t\t\tresultGroups.push([]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (g.field) {\n\t\t\t\t// `relatives` are actual relatives. We'll skim them for FK query values.\n\t\t\t\t// Use the relatives to add candidate result sets (`resultGroups`)\n\n\t\t\t\tconst relationship = ModelRelationship.from(this.model, g.field);\n\n\t\t\t\tif (relationship) {\n\t\t\t\t\tconst relativesPredicates: ((\n\t\t\t\t\t\tp: RecursiveModelPredicate<any>\n\t\t\t\t\t) => RecursiveModelPredicate<any>)[] = [];\n\t\t\t\t\tfor (const relative of relatives) {\n\t\t\t\t\t\tconst individualRowJoinConditions: FieldCondition[] = [];\n\n\t\t\t\t\t\tfor (let i = 0; i < relationship.localJoinFields.length; i++) {\n\t\t\t\t\t\t\t// rightHandValue\n\t\t\t\t\t\t\tindividualRowJoinConditions.push(\n\t\t\t\t\t\t\t\tnew FieldCondition(relationship.localJoinFields[i], 'eq', [\n\t\t\t\t\t\t\t\t\trelative[relationship.remoteJoinFields[i]],\n\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst predicate = p =>\n\t\t\t\t\t\t\tapplyConditionsToV1Predicate(\n\t\t\t\t\t\t\t\tp,\n\t\t\t\t\t\t\t\tindividualRowJoinConditions,\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\trelativesPredicates.push(predicate as any);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst predicate = FlatModelPredicateCreator.createGroupFromExisting(\n\t\t\t\t\t\tthis.model.schema,\n\t\t\t\t\t\t'or',\n\t\t\t\t\t\trelativesPredicates as any\n\t\t\t\t\t);\n\n\t\t\t\t\tresultGroups.push(\n\t\t\t\t\t\tawait storage.query(this.model.builder, predicate as any)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Missing field metadata.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// relatives are not actually relatives. they're candidate results.\n\t\t\t\tresultGroups.push(relatives);\n\t\t\t}\n\t\t}\n\n\t\t// if conditions is empty at this point, child predicates found no matches.\n\t\t// i.e., we can stop looking and return empty.\n\t\tif (conditions.length > 0) {\n\t\t\tconst predicate = FlatModelPredicateCreator.createFromExisting(\n\t\t\t\tthis.model.schema,\n\t\t\t\tp =>\n\t\t\t\t\tp[operator](c =>\n\t\t\t\t\t\tapplyConditionsToV1Predicate(c, conditions, negateChildren)\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tresultGroups.push(\n\t\t\t\tawait storage.query(this.model.builder, predicate as any)\n\t\t\t);\n\t\t} else if (conditions.length === 0 && resultGroups.length === 0) {\n\t\t\tresultGroups.push(await storage.query(this.model.builder));\n\t\t}\n\n\t\t// PK might be a single field, like `id`, or it might be several fields.\n\t\t// so, we'll need to extract the list of PK fields from an object\n\t\t// and stringify the list for easy comparison / merging.\n\t\tconst getPKValue = item =>\n\t\t\tJSON.stringify(this.model.pkField.map(name => item[name]));\n\n\t\t// will be used for intersecting or unioning results\n\t\tlet resultIndex: Map<string, Record<string, any>> | undefined;\n\n\t\tif (operator === 'and') {\n\t\t\tif (resultGroups.length === 0) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// for each group, we intersect, removing items from the result index\n\t\t\t// that aren't present in each subsequent group.\n\t\t\tfor (const group of resultGroups) {\n\t\t\t\tif (resultIndex === undefined) {\n\t\t\t\t\tresultIndex = new Map(group.map(item => [getPKValue(item), item]));\n\t\t\t\t} else {\n\t\t\t\t\tconst intersectWith = new Map<string, Record<string, any>>(\n\t\t\t\t\t\tgroup.map(item => [getPKValue(item), item])\n\t\t\t\t\t);\n\t\t\t\t\tfor (const k of resultIndex.keys()) {\n\t\t\t\t\t\tif (!intersectWith.has(k)) {\n\t\t\t\t\t\t\tresultIndex.delete(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (operator === 'or' || operator === 'not') {\n\t\t\t// it's OK to handle NOT here, because NOT must always only negate\n\t\t\t// a single child predicate. NOT logic will have been distributed down\n\t\t\t// to the leaf conditions already.\n\n\t\t\tresultIndex = new Map();\n\n\t\t\t// just merge the groups, performing DISTINCT-ification by ID.\n\t\t\tfor (const group of resultGroups) {\n\t\t\t\tfor (const item of group) {\n\t\t\t\t\tresultIndex.set(getPKValue(item), item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(resultIndex?.values() || []);\n\t}\n\n\t/**\n\t * Determines whether a single item matches the conditions of `this`.\n\t * When checking the target `item`'s properties, each property will be `await`'d\n\t * to ensure lazy-loading is respected where applicable.\n\t * @param item The item to match against.\n\t * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n\t * (Used for iterating over children on HAS_MANY checks.)\n\t * @returns A boolean (promise): `true` if matched, `false` otherwise.\n\t */\n\tasync matches(\n\t\titem: Record<string, any>,\n\t\tignoreFieldName: boolean = false\n\t): Promise<boolean> {\n\t\tconst itemToCheck =\n\t\t\tthis.field && !ignoreFieldName ? await item[this.field] : item;\n\n\t\t// if there is no item to check, we can stop recursing immediately.\n\t\t// a condition cannot match against an item that does not exist. this\n\t\t// can occur when `item.field` is optional in the schema.\n\t\tif (!itemToCheck) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\tthis.relationshipType === 'HAS_MANY' &&\n\t\t\ttypeof itemToCheck[Symbol.asyncIterator] === 'function'\n\t\t) {\n\t\t\tfor await (const singleItem of itemToCheck) {\n\t\t\t\tif (await this.matches(singleItem, true)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.operator === 'or') {\n\t\t\treturn asyncSome(this.operands, c => c.matches(itemToCheck));\n\t\t} else if (this.operator === 'and') {\n\t\t\treturn asyncEvery(this.operands, c => c.matches(itemToCheck));\n\t\t} else if (this.operator === 'not') {\n\t\t\tif (this.operands.length !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Invalid arguments! `not()` accepts exactly one predicate expression.'\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn !(await this.operands[0].matches(itemToCheck));\n\t\t} else {\n\t\t\tthrow new Error('Invalid group operator!');\n\t\t}\n\t}\n\n\t/**\n\t * Tranfsorm to a AppSync GraphQL compatible AST.\n\t * (Does not support filtering in nested types.)\n\t */\n\ttoAST() {\n\t\tif (this.field)\n\t\t\tthrow new Error('Nested type conditions are not supported!');\n\n\t\treturn {\n\t\t\t[this.operator]: this.operands.map(operand => operand.toAST()),\n\t\t};\n\t}\n\n\ttoStoragePredicate<T>(\n\t\tbaseCondition?: StoragePredicate<T>\n\t): StoragePredicate<T> {\n\t\treturn FlatModelPredicateCreator.createFromAST(\n\t\t\tthis.model.schema,\n\t\t\tthis.toAST()\n\t\t) as unknown as StoragePredicate<T>;\n\t}\n}\n\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * TODO: the sortof-immutable algorithm was originally done to support legacy style\n * predicate branching (`p => p.x.eq(value).y.eq(value)`). i'm not sure this is\n * necessary or beneficial at this point, since we decided that each field condition\n * must flly terminate a branch. is the strong mutation barrier between chain links\n * still necessary or helpful?\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\nexport function recursivePredicateFor<T extends PersistentModel>(\n\tModelType: ModelMeta<T>,\n\tallowRecursion: boolean = true,\n\tfield?: string,\n\tquery?: GroupCondition,\n\ttail?: GroupCondition\n): RecursiveModelPredicate<T> & PredicateInternalsKey {\n\t// to be used if we don't have a base query or tail to build onto\n\tconst starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n\n\tconst baseCondition = query && tail ? query : starter;\n\tconst tailCondition = query && tail ? tail : starter;\n\n\t// our eventual return object, which can be built upon.\n\t// next steps will be to add or(), and(), not(), and field.op() methods.\n\tconst link = {} as any;\n\n\tregisterPredicateInternals(baseCondition, link);\n\n\tconst copyLink = () => {\n\t\tconst [query, newTail] = baseCondition.copy(tailCondition);\n\t\tconst newLink = recursivePredicateFor(\n\t\t\tModelType,\n\t\t\tallowRecursion,\n\t\t\tundefined,\n\t\t\tquery,\n\t\t\tnewTail\n\t\t);\n\t\treturn { query, newTail, newLink };\n\t};\n\n\t// Adds .or() and .and() methods to the link.\n\t// TODO: If revisiting this code, consider writing a Proxy instead.\n\t['and', 'or'].forEach(op => {\n\t\t(link as any)[op] = (\n\t\t\tbuilder: RecursiveModelPredicateAggregateExtender<T>\n\t\t) => {\n\t\t\t// or() and and() will return a copy of the original link\n\t\t\t// to head off mutability concerns.\n\t\t\tconst { query, newTail } = copyLink();\n\n\t\t\tconst childConditions = builder(\n\t\t\t\trecursivePredicateFor(ModelType, allowRecursion)\n\t\t\t);\n\t\t\tif (!Array.isArray(childConditions)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid predicate. \\`${op}\\` groups must return an array of child conditions.`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// the customer will supply a child predicate, which apply to the `model.field`\n\t\t\t// of the tail GroupCondition.\n\t\t\tnewTail?.operands.push(\n\t\t\t\tnew GroupCondition(\n\t\t\t\t\tModelType,\n\t\t\t\t\tfield,\n\t\t\t\t\tundefined,\n\t\t\t\t\top as 'and' | 'or',\n\t\t\t\t\tchildConditions.map(c => internals(c))\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// FinalPredicate\n\t\t\treturn registerPredicateInternals(query);\n\t\t};\n\t});\n\n\t// TODO: If revisiting this code, consider proxy.\n\tlink.not = (\n\t\tbuilder: RecursiveModelPredicateExtender<T>\n\t): PredicateInternalsKey => {\n\t\t// not() will return a copy of the original link\n\t\t// to head off mutability concerns.\n\t\tconst { query, newTail } = copyLink();\n\n\t\t// unlike and() and or(), the customer will supply a \"singular\" child predicate.\n\t\t// the difference being: not() does not accept an array of predicate-like objects.\n\t\t// it negates only a *single* predicate subtree.\n\t\tnewTail?.operands.push(\n\t\t\tnew GroupCondition(ModelType, field, undefined, 'not', [\n\t\t\t\tinternals(builder(recursivePredicateFor(ModelType, allowRecursion))),\n\t\t\t])\n\t\t);\n\n\t\t// A `FinalModelPredicate`.\n\t\t// Return a thing that can no longer be extended, but instead used to `async filter(items)`\n\t\t// or query storage: `.__query.fetch(storage)`.\n\t\treturn registerPredicateInternals(query);\n\t};\n\n\t// For each field on the model schema, we want to add a getter\n\t// that creates the appropriate new `link` in the query chain.\n\t// TODO: If revisiting, consider a proxy.\n\tfor (const fieldName in ModelType.schema.fields) {\n\t\tObject.defineProperty(link, fieldName, {\n\t\t\tenumerable: true,\n\t\t\tget: () => {\n\t\t\t\tconst def = ModelType.schema.fields[fieldName];\n\n\t\t\t\tif (!def.association) {\n\t\t\t\t\t// we're looking at a value field. we need to return a\n\t\t\t\t\t// \"field matcher object\", which contains all of the comparison\n\t\t\t\t\t// functions ('eq', 'ne', 'gt', etc.), scoped to operate\n\t\t\t\t\t// against the target field (fieldName).\n\t\t\t\t\treturn ops.reduce((fieldMatcher, operator) => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...fieldMatcher,\n\n\t\t\t\t\t\t\t// each operator on the fieldMatcher objcect is a function.\n\t\t\t\t\t\t\t// when the customer calls the function, it returns a new link\n\t\t\t\t\t\t\t// in the chain -- for now -- this is the \"leaf\" link that\n\t\t\t\t\t\t\t// cannot be further extended.\n\t\t\t\t\t\t\t[operator]: (...operands: any[]) => {\n\t\t\t\t\t\t\t\t// build off a fresh copy of the existing `link`, just in case\n\t\t\t\t\t\t\t\t// the same link is being used elsewhere by the customer.\n\t\t\t\t\t\t\t\tconst { query, newTail } = copyLink();\n\n\t\t\t\t\t\t\t\t// add the given condition to the link's TAIL node.\n\t\t\t\t\t\t\t\t// remember: the base link might go N nodes deep! e.g.,\n\t\t\t\t\t\t\t\tnewTail?.operands.push(\n\t\t\t\t\t\t\t\t\tnew FieldCondition(fieldName, operator, operands)\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t// A `FinalModelPredicate`.\n\t\t\t\t\t\t\t\t// Return a thing that can no longer be extended, but instead used to `async filter(items)`\n\t\t\t\t\t\t\t\t// or query storage: `.__query.fetch(storage)`.\n\t\t\t\t\t\t\t\treturn registerPredicateInternals(query);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\t\t\t\t\t}, {});\n\t\t\t\t} else {\n\t\t\t\t\tif (!allowRecursion) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Predication on releated models is not supported in this context.'\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tdef.association.connectionType === 'BELONGS_TO' ||\n\t\t\t\t\t\tdef.association.connectionType === 'HAS_ONE' ||\n\t\t\t\t\t\tdef.association.connectionType === 'HAS_MANY'\n\t\t\t\t\t) {\n\t\t\t\t\t\t// the use has just typed '.someRelatedModel'. we need to given them\n\t\t\t\t\t\t// back a predicate chain.\n\n\t\t\t\t\t\tconst relatedMeta = (def.type as ModelFieldType).modelConstructor;\n\t\t\t\t\t\tif (!relatedMeta) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t'Related model metadata is missing. This is a bug! Please report it.'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// `Model.reletedModelField` returns a copy of the original link,\n\t\t\t\t\t\t// and will contains copies of internal GroupConditions\n\t\t\t\t\t\t// to head off mutability concerns.\n\t\t\t\t\t\tconst [newquery, oldtail] = baseCondition.copy(tailCondition);\n\t\t\t\t\t\tconst newtail = new GroupCondition(\n\t\t\t\t\t\t\trelatedMeta,\n\t\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\t\tdef.association.connectionType,\n\t\t\t\t\t\t\t'and',\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// `oldtail` here refers to the *copy* of the old tail.\n\t\t\t\t\t\t// so, it's safe to modify at this point. and we need to modify\n\t\t\t\t\t\t// it to push the *new* tail onto the end of it.\n\t\t\t\t\t\t(oldtail as GroupCondition).operands.push(newtail);\n\t\t\t\t\t\tconst newlink = recursivePredicateFor(\n\t\t\t\t\t\t\trelatedMeta,\n\t\t\t\t\t\t\tallowRecursion,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tnewquery,\n\t\t\t\t\t\t\tnewtail\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn newlink;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"Related model definition doesn't have a typedef. This is a bug! Please report it.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n\n\treturn link;\n}\n\nexport function predicateFor<T extends PersistentModel>(\n\tModelType: ModelMeta<T>\n): ModelPredicate<T> & PredicateInternalsKey {\n\treturn recursivePredicateFor(ModelType, false) as any as ModelPredicate<T>;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}