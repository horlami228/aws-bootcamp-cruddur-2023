{"ast":null,"code":"import { __awaiter, __extends, __generator, __read, __rest, __spread } from \"tslib\";\nimport Observable from 'zen-observable-ts';\nimport { ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { MqttOverWSProvider } from './MqttOverWSProvider';\nvar logger = new Logger('AWSAppSyncProvider');\n/**\n * @deprecated Unused, all usecases have migrated to AWSAppSyncRealtimeProvider\n */\nvar AWSAppSyncProvider = /** @class */function (_super) {\n  __extends(AWSAppSyncProvider, _super);\n  function AWSAppSyncProvider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._topicClient = new Map();\n    _this._topicAlias = new Map();\n    return _this;\n  }\n  Object.defineProperty(AWSAppSyncProvider.prototype, \"endpoint\", {\n    get: function () {\n      throw new Error('Not supported');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  AWSAppSyncProvider.prototype.getProviderName = function () {\n    return 'AWSAppSyncProvider';\n  };\n  AWSAppSyncProvider.prototype.publish = function (topics, msg, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error('Operation not supported');\n      });\n    });\n  };\n  AWSAppSyncProvider.prototype._cleanUp = function (clientId) {\n    var _this = this;\n    var topicsForClient = Array.from(this._topicClient.entries()).filter(function (_a) {\n      var _b = __read(_a, 2),\n        c = _b[1];\n      return c.clientId === clientId;\n    }).map(function (_a) {\n      var _b = __read(_a, 1),\n        t = _b[0];\n      return t;\n    });\n    topicsForClient.forEach(function (t) {\n      return _this._cleanUpForTopic(t);\n    });\n  };\n  AWSAppSyncProvider.prototype._cleanUpForTopic = function (topic) {\n    this._topicClient.delete(topic);\n    this._topicAlias.delete(topic);\n  };\n  AWSAppSyncProvider.prototype.onDisconnect = function (_a) {\n    var _this = this;\n    var clientId = _a.clientId,\n      errorCode = _a.errorCode,\n      args = __rest(_a, [\"clientId\", \"errorCode\"]);\n    if (errorCode !== 0) {\n      var topicsForClient = Array.from(this._topicClient.entries()).filter(function (_a) {\n        var _b = __read(_a, 2),\n          c = _b[1];\n        return c.clientId === clientId;\n      }).map(function (_a) {\n        var _b = __read(_a, 1),\n          t = _b[0];\n        return t;\n      });\n      topicsForClient.forEach(function (topic) {\n        if (_this._topicObservers.has(topic)) {\n          _this._topicObservers.get(topic).forEach(function (obs) {\n            if (!obs.closed) {\n              obs.error(args);\n            }\n          });\n          _this._topicObservers.delete(topic);\n        }\n      });\n      this._cleanUp(clientId);\n    }\n  };\n  AWSAppSyncProvider.prototype.disconnect = function (clientId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var client;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.clientsQueue.get(clientId, function () {\n              return null;\n            })];\n          case 1:\n            client = _a.sent();\n            return [4 /*yield*/, _super.prototype.disconnect.call(this, clientId)];\n          case 2:\n            _a.sent();\n            this._cleanUp(clientId);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncProvider.prototype.subscribe = function (topics, options) {\n    var _this = this;\n    if (options === void 0) {\n      options = {};\n    }\n    var result = new Observable(function (observer) {\n      var targetTopics = [].concat(topics);\n      logger.debug('Subscribing to topic(s)', targetTopics.join(','));\n      (function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var _a, mqttConnections, newSubscriptions, newAliases, map;\n          var _this = this;\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                // Add these topics to map\n                targetTopics.forEach(function (t) {\n                  if (!_this._topicObservers.has(t)) {\n                    _this._topicObservers.set(t, new Set());\n                  }\n                  _this._topicObservers.get(t).add(observer);\n                });\n                _a = options.mqttConnections, mqttConnections = _a === void 0 ? [] : _a, newSubscriptions = options.newSubscriptions;\n                newAliases = Object.entries(newSubscriptions).map(function (_a) {\n                  var _b = __read(_a, 2),\n                    alias = _b[0],\n                    v = _b[1];\n                  return [v.topic, alias];\n                });\n                // Merge new aliases with old ones\n                this._topicAlias = new Map(__spread(Array.from(this._topicAlias.entries()), newAliases));\n                map = Object.entries(targetTopics.reduce(function (acc, elem) {\n                  var connectionInfoForTopic = mqttConnections.find(function (c) {\n                    return c.topics.indexOf(elem) > -1;\n                  });\n                  if (connectionInfoForTopic) {\n                    var clientId = connectionInfoForTopic.client,\n                      url = connectionInfoForTopic.url;\n                    if (!acc[clientId]) {\n                      acc[clientId] = {\n                        url: url,\n                        topics: new Set()\n                      };\n                    }\n                    acc[clientId].topics.add(elem);\n                  }\n                  return acc;\n                }, {}));\n                // reconnect everything we have in the map\n                return [4 /*yield*/, Promise.all(map.map(function (_a) {\n                  var _b = __read(_a, 2),\n                    clientId = _b[0],\n                    _c = _b[1],\n                    url = _c.url,\n                    topics = _c.topics;\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var client, err_1;\n                    var _this = this;\n                    return __generator(this, function (_d) {\n                      switch (_d.label) {\n                        case 0:\n                          client = null;\n                          _d.label = 1;\n                        case 1:\n                          _d.trys.push([1, 3,, 4]);\n                          return [4 /*yield*/, this.connect(clientId, {\n                            clientId: clientId,\n                            url: url\n                          })];\n                        case 2:\n                          client = _d.sent();\n                          return [3 /*break*/, 4];\n                        case 3:\n                          err_1 = _d.sent();\n                          observer.error({\n                            message: 'Failed to connect',\n                            error: err_1\n                          });\n                          observer.complete();\n                          return [2 /*return*/, undefined];\n                        case 4:\n                          // subscribe to all topics for this client\n                          // store topic-client mapping\n                          topics.forEach(function (topic) {\n                            if (client.isConnected()) {\n                              client.subscribe(topic);\n                              _this._topicClient.set(topic, client);\n                            }\n                          });\n                          return [2 /*return*/, client];\n                      }\n                    });\n                  });\n                }))];\n              case 1:\n                // reconnect everything we have in the map\n                _b.sent();\n                return [2 /*return*/];\n            }\n          });\n        });\n      })();\n\n      return function () {\n        logger.debug('Unsubscribing from topic(s)', targetTopics.join(','));\n        targetTopics.forEach(function (t) {\n          var client = _this._topicClient.get(t);\n          if (client && client.isConnected()) {\n            client.unsubscribe(t);\n            _this._topicClient.delete(t);\n            if (!Array.from(_this._topicClient.values()).some(function (c) {\n              return c === client;\n            })) {\n              _this.disconnect(client.clientId);\n            }\n          }\n          _this._topicObservers.delete(t);\n        });\n      };\n    });\n    return Observable.from(result).map(function (value) {\n      var topic = _this.getTopicForValue(value);\n      var alias = _this._topicAlias.get(topic);\n      value.data = Object.entries(value.data).reduce(function (obj, _a) {\n        var _b = __read(_a, 2),\n          origKey = _b[0],\n          val = _b[1];\n        return obj[alias || origKey] = val, obj;\n      }, {});\n      return value;\n    });\n  };\n  return AWSAppSyncProvider;\n}(MqttOverWSProvider);\nexport { AWSAppSyncProvider };","map":{"version":3,"mappings":"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","names":["Observable","ConsoleLogger","Logger","MqttOverWSProvider","logger","__extends","_this","Map","Object","AWSAppSyncProvider","Error","topics","msg","options","clientId","topicsForClient","Array","from","_topicClient","entries","filter","_a","_b","c","map","t","forEach","_cleanUpForTopic","topic","delete","_topicAlias","errorCode","args","_topicObservers","has","get","obs","closed","error","_cleanUp","clientsQueue","client","_super","disconnect","result","targetTopics","concat","debug","join","set","Set","add","observer","mqttConnections","newSubscriptions","newAliases","alias","v","reduce","acc","elem","connectionInfoForTopic","find","indexOf","url","Promise","all","_c","connect","_d","message","err_1","complete","undefined","isConnected","subscribe","unsubscribe","values","some","getTopicForValue","value","data","obj","origKey","val"],"sources":["/frontend-react-js/node_modules/@aws-amplify/pubsub/src/Providers/AWSAppSyncProvider.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Client } from 'paho-mqtt';\nimport Observable from 'zen-observable-ts';\nimport { ConsoleLogger as Logger } from '@aws-amplify/core';\n\nimport { MqttOverWSProvider } from './MqttOverWSProvider';\n\nconst logger = new Logger('AWSAppSyncProvider');\n\n/**\n * @deprecated Unused, all usecases have migrated to AWSAppSyncRealtimeProvider\n */\nexport class AWSAppSyncProvider extends MqttOverWSProvider {\n\tprotected get endpoint() {\n\t\tthrow new Error('Not supported');\n\t}\n\n\tgetProviderName() {\n\t\treturn 'AWSAppSyncProvider';\n\t}\n\n\tpublic async publish(topics: string[] | string, msg: any, options?: any) {\n\t\tthrow new Error('Operation not supported');\n\t}\n\n\tprivate _cleanUp(clientId: string) {\n\t\tconst topicsForClient = Array.from(this._topicClient.entries())\n\t\t\t.filter(([, c]) => c.clientId === clientId)\n\t\t\t.map(([t]) => t);\n\n\t\ttopicsForClient.forEach(t => this._cleanUpForTopic(t));\n\t}\n\n\tprivate _cleanUpForTopic(topic) {\n\t\tthis._topicClient.delete(topic);\n\t\tthis._topicAlias.delete(topic);\n\t}\n\n\tpublic onDisconnect({ clientId, errorCode, ...args }) {\n\t\tif (errorCode !== 0) {\n\t\t\tconst topicsForClient = Array.from(this._topicClient.entries())\n\t\t\t\t.filter(([, c]) => c.clientId === clientId)\n\t\t\t\t.map(([t]) => t);\n\n\t\t\ttopicsForClient.forEach(topic => {\n\t\t\t\tif (this._topicObservers.has(topic)) {\n\t\t\t\t\tthis._topicObservers.get(topic).forEach(obs => {\n\t\t\t\t\t\tif (!obs.closed) {\n\t\t\t\t\t\t\tobs.error(args);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tthis._topicObservers.delete(topic);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._cleanUp(clientId);\n\t\t}\n\t}\n\n\tprivate _topicClient: Map<string, Client> = new Map();\n\n\tprivate _topicAlias: Map<string, string> = new Map();\n\n\tprotected async disconnect(clientId: string): Promise<void> {\n\t\tconst client = await this.clientsQueue.get(clientId, () => null);\n\n\t\tawait super.disconnect(clientId);\n\n\t\tthis._cleanUp(clientId);\n\t}\n\n\tsubscribe(topics: string[] | string, options: any = {}): Observable<any> {\n\t\tconst result = new Observable<any>(observer => {\n\t\t\tconst targetTopics = ([] as string[]).concat(topics);\n\t\t\tlogger.debug('Subscribing to topic(s)', targetTopics.join(','));\n\n\t\t\t(async () => {\n\t\t\t\t// Add these topics to map\n\t\t\t\ttargetTopics.forEach(t => {\n\t\t\t\t\tif (!this._topicObservers.has(t)) {\n\t\t\t\t\t\tthis._topicObservers.set(t, new Set());\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._topicObservers.get(t).add(observer);\n\t\t\t\t});\n\n\t\t\t\tconst { mqttConnections = [], newSubscriptions } = options;\n\n\t\t\t\t// creates a map of {\"topic\": \"alias\"}\n\t\t\t\tconst newAliases = Object.entries(newSubscriptions).map(\n\t\t\t\t\t([alias, v]: [string, { topic: string }]) => [v.topic, alias]\n\t\t\t\t);\n\n\t\t\t\t// Merge new aliases with old ones\n\t\t\t\tthis._topicAlias = new Map([\n\t\t\t\t\t...Array.from(this._topicAlias.entries()),\n\t\t\t\t\t...(newAliases as [string, string][]),\n\t\t\t\t]);\n\n\t\t\t\t// group by urls\n\t\t\t\tconst map: [string, { url: string; topics: Set<string> }][] =\n\t\t\t\t\tObject.entries(\n\t\t\t\t\t\ttargetTopics.reduce((acc, elem) => {\n\t\t\t\t\t\t\tconst connectionInfoForTopic = mqttConnections.find(\n\t\t\t\t\t\t\t\tc => c.topics.indexOf(elem) > -1\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (connectionInfoForTopic) {\n\t\t\t\t\t\t\t\tconst { client: clientId, url } = connectionInfoForTopic;\n\n\t\t\t\t\t\t\t\tif (!acc[clientId]) {\n\t\t\t\t\t\t\t\t\tacc[clientId] = {\n\t\t\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\t\t\ttopics: new Set(),\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tacc[clientId].topics.add(elem);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn acc;\n\t\t\t\t\t\t}, {})\n\t\t\t\t\t);\n\n\t\t\t\t// reconnect everything we have in the map\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tmap.map(async ([clientId, { url, topics }]) => {\n\t\t\t\t\t\t// connect to new client\n\t\t\t\t\t\tlet client = null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tclient = await this.connect(clientId, {\n\t\t\t\t\t\t\t\tclientId,\n\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tobserver.error({ message: 'Failed to connect', error: err });\n\t\t\t\t\t\t\tobserver.complete();\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// subscribe to all topics for this client\n\t\t\t\t\t\t// store topic-client mapping\n\t\t\t\t\t\ttopics.forEach(topic => {\n\t\t\t\t\t\t\tif (client.isConnected()) {\n\t\t\t\t\t\t\t\tclient.subscribe(topic);\n\n\t\t\t\t\t\t\t\tthis._topicClient.set(topic, client);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn client;\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t})();\n\n\t\t\treturn () => {\n\t\t\t\tlogger.debug('Unsubscribing from topic(s)', targetTopics.join(','));\n\n\t\t\t\ttargetTopics.forEach(t => {\n\t\t\t\t\tconst client = this._topicClient.get(t);\n\n\t\t\t\t\tif (client && client.isConnected()) {\n\t\t\t\t\t\tclient.unsubscribe(t);\n\t\t\t\t\t\tthis._topicClient.delete(t);\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!Array.from(this._topicClient.values()).some(c => c === client)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.disconnect(client.clientId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._topicObservers.delete(t);\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\n\t\treturn Observable.from(result).map(value => {\n\t\t\tconst topic = this.getTopicForValue(value);\n\t\t\tconst alias = this._topicAlias.get(topic);\n\n\t\t\tvalue.data = Object.entries(value.data).reduce(\n\t\t\t\t(obj, [origKey, val]) => (\n\t\t\t\t\t(obj[(alias || origKey) as string] = val), obj\n\t\t\t\t),\n\t\t\t\t{}\n\t\t\t);\n\n\t\t\treturn value;\n\t\t});\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}