{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __rest } from \"tslib\";\nimport { ModelPredicateCreator } from '../predicates';\nimport { QueryOne } from '../types';\nimport { USER, SYNC, valuesEqual } from '../util';\nimport { getIdentifierValue, TransformerMutationType } from './utils';\n// TODO: Persist deleted ids\n// https://github.com/aws-amplify/amplify-js/blob/datastore-docs/packages/datastore/docs/sync-engine.md#outbox\nvar MutationEventOutbox = /** @class */function () {\n  function MutationEventOutbox(schema, MutationEvent, modelInstanceCreator, ownSymbol) {\n    this.schema = schema;\n    this.MutationEvent = MutationEvent;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.ownSymbol = ownSymbol;\n  }\n  MutationEventOutbox.prototype.enqueue = function (storage, mutationEvent) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, storage.runExclusive(function (s) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var mutationEventModelDefinition, predicate, _a, first, incomingMutationType, merged_1, incomingConditionJSON, incomingCondition, merged;\n                var _this = this;\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      mutationEventModelDefinition = this.schema.namespaces[SYNC].models['MutationEvent'];\n                      predicate = ModelPredicateCreator.createFromExisting(mutationEventModelDefinition, function (c) {\n                        return c.modelId('eq', mutationEvent.modelId).id('ne', _this.inProgressMutationEventId);\n                      });\n                      return [4 /*yield*/, s.query(this.MutationEvent, predicate)];\n                    case 1:\n                      _a = __read.apply(void 0, [_b.sent(), 1]), first = _a[0];\n                      if (!(first === undefined)) return [3 /*break*/, 3];\n                      return [4 /*yield*/, s.save(mutationEvent, undefined, this.ownSymbol)];\n                    case 2:\n                      _b.sent();\n                      return [2 /*return*/];\n                    case 3:\n                      incomingMutationType = mutationEvent.operation;\n                      if (!(first.operation === TransformerMutationType.CREATE)) return [3 /*break*/, 8];\n                      if (!(incomingMutationType === TransformerMutationType.DELETE)) return [3 /*break*/, 5];\n                      return [4 /*yield*/, s.delete(this.MutationEvent, predicate)];\n                    case 4:\n                      _b.sent();\n                      return [3 /*break*/, 7];\n                    case 5:\n                      merged_1 = this.mergeUserFields(first, mutationEvent);\n                      return [4 /*yield*/, s.save(this.MutationEvent.copyOf(first, function (draft) {\n                        draft.data = merged_1.data;\n                      }), undefined, this.ownSymbol)];\n                    case 6:\n                      _b.sent();\n                      _b.label = 7;\n                    case 7:\n                      return [3 /*break*/, 12];\n                    case 8:\n                      incomingConditionJSON = mutationEvent.condition;\n                      incomingCondition = JSON.parse(incomingConditionJSON);\n                      merged = void 0;\n                      if (!(Object.keys(incomingCondition).length === 0)) return [3 /*break*/, 10];\n                      merged = this.mergeUserFields(first, mutationEvent);\n                      // delete all for model\n                      return [4 /*yield*/, s.delete(this.MutationEvent, predicate)];\n                    case 9:\n                      // delete all for model\n                      _b.sent();\n                      _b.label = 10;\n                    case 10:\n                      merged = merged || mutationEvent;\n                      // Enqueue new one\n                      return [4 /*yield*/, s.save(merged, undefined, this.ownSymbol)];\n                    case 11:\n                      // Enqueue new one\n                      _b.sent();\n                      _b.label = 12;\n                    case 12:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            })];\n\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationEventOutbox.prototype.dequeue = function (storage, record, recordOp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var head;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.peek(storage)];\n          case 1:\n            head = _a.sent();\n            if (!record) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.syncOutboxVersionsOnDequeue(storage, record, head, recordOp)];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            return [4 /*yield*/, storage.delete(head)];\n          case 4:\n            _a.sent();\n            this.inProgressMutationEventId = undefined;\n            return [2 /*return*/, head];\n        }\n      });\n    });\n  };\n  /**\n   * Doing a peek() implies that the mutation goes \"inProgress\"\n   *\n   * @param storage\n   */\n  MutationEventOutbox.prototype.peek = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      var head;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, storage.queryOne(this.MutationEvent, QueryOne.FIRST)];\n          case 1:\n            head = _a.sent();\n            this.inProgressMutationEventId = head ? head.id : undefined;\n            return [2 /*return*/, head];\n        }\n      });\n    });\n  };\n  MutationEventOutbox.prototype.getForModel = function (storage, model, userModelDefinition) {\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationEventModelDefinition, modelId, mutationEvents;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            mutationEventModelDefinition = this.schema.namespaces[SYNC].models.MutationEvent;\n            modelId = getIdentifierValue(userModelDefinition, model);\n            return [4 /*yield*/, storage.query(this.MutationEvent, ModelPredicateCreator.createFromExisting(mutationEventModelDefinition, function (c) {\n              return c.modelId('eq', modelId);\n            }))];\n          case 1:\n            mutationEvents = _a.sent();\n            return [2 /*return*/, mutationEvents];\n        }\n      });\n    });\n  };\n  MutationEventOutbox.prototype.getModelIds = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationEvents, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, storage.query(this.MutationEvent)];\n          case 1:\n            mutationEvents = _a.sent();\n            result = new Set();\n            mutationEvents.forEach(function (_a) {\n              var modelId = _a.modelId;\n              return result.add(modelId);\n            });\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  // applies _version from the AppSync mutation response to other items\n  // in the mutation queue with the same id\n  // see https://github.com/aws-amplify/amplify-js/pull/7354 for more details\n  MutationEventOutbox.prototype.syncOutboxVersionsOnDequeue = function (storage, record, head, recordOp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _version, _lastChangedAt, _deleted, _incomingData, incomingData, data, __version, __lastChangedAt, __deleted, _outgoingData, outgoingData, mutationEventModelDefinition, userModelDefinition, recordId, predicate, outdatedMutations, reconciledMutations;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (head.operation !== recordOp) {\n              return [2 /*return*/];\n            }\n\n            _version = record._version, _lastChangedAt = record._lastChangedAt, _deleted = record._deleted, _incomingData = __rest(record, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n            incomingData = this.removeTimestampFields(head.model, _incomingData);\n            data = JSON.parse(head.data);\n            if (!data) {\n              return [2 /*return*/];\n            }\n\n            __version = data._version, __lastChangedAt = data._lastChangedAt, __deleted = data._deleted, _outgoingData = __rest(data, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n            outgoingData = this.removeTimestampFields(head.model, _outgoingData);\n            // Don't sync the version when the data in the response does not match the data\n            // in the request, i.e., when there's a handled conflict\n            if (!valuesEqual(incomingData, outgoingData, true)) {\n              return [2 /*return*/];\n            }\n\n            mutationEventModelDefinition = this.schema.namespaces[SYNC].models['MutationEvent'];\n            userModelDefinition = this.schema.namespaces['user'].models[head.model];\n            recordId = getIdentifierValue(userModelDefinition, record);\n            predicate = ModelPredicateCreator.createFromExisting(mutationEventModelDefinition, function (c) {\n              return c.modelId('eq', recordId).id('ne', _this.inProgressMutationEventId);\n            });\n            return [4 /*yield*/, storage.query(this.MutationEvent, predicate)];\n          case 1:\n            outdatedMutations = _a.sent();\n            if (!outdatedMutations.length) {\n              return [2 /*return*/];\n            }\n\n            reconciledMutations = outdatedMutations.map(function (m) {\n              var oldData = JSON.parse(m.data);\n              var newData = __assign(__assign({}, oldData), {\n                _version: _version,\n                _lastChangedAt: _lastChangedAt\n              });\n              return _this.MutationEvent.copyOf(m, function (draft) {\n                draft.data = JSON.stringify(newData);\n              });\n            });\n            return [4 /*yield*/, storage.delete(this.MutationEvent, predicate)];\n          case 2:\n            _a.sent();\n            return [4 /*yield*/, Promise.all(reconciledMutations.map(function (m) {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4 /*yield*/, storage.save(m, undefined, this.ownSymbol)];\n                    case 1:\n                      return [2 /*return*/, _a.sent()];\n                  }\n                });\n              });\n            }))];\n          case 3:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationEventOutbox.prototype.mergeUserFields = function (previous, current) {\n    var _a = JSON.parse(previous.data),\n      _version = _a._version,\n      _lastChangedAt = _a._lastChangedAt,\n      _deleted = _a._deleted,\n      previousData = __rest(_a, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n    var _b = JSON.parse(current.data),\n      __version = _b._version,\n      __lastChangedAt = _b._lastChangedAt,\n      __deleted = _b._deleted,\n      currentData = __rest(_b, [\"_version\", \"_lastChangedAt\", \"_deleted\"]);\n    var data = JSON.stringify(__assign(__assign({\n      _version: _version,\n      _lastChangedAt: _lastChangedAt,\n      _deleted: _deleted\n    }, previousData), currentData));\n    return this.modelInstanceCreator(this.MutationEvent, __assign(__assign({}, current), {\n      data: data\n    }));\n  };\n  /*\n  if a model is using custom timestamp fields\n  the custom field names will be stored in the model attributes\n   e.g.\n  \"attributes\": [\n  {\n          \"type\": \"model\",\n          \"properties\": {\n              \"timestamps\": {\n                  \"createdAt\": \"createdOn\",\n                  \"updatedAt\": \"updatedOn\"\n              }\n          }\n  }\n  ]\n  */\n  MutationEventOutbox.prototype.removeTimestampFields = function (model, record) {\n    var _a, _b;\n    var CREATED_AT_DEFAULT_KEY = 'createdAt';\n    var UPDATED_AT_DEFAULT_KEY = 'updatedAt';\n    var createdTimestampKey = CREATED_AT_DEFAULT_KEY;\n    var updatedTimestampKey = UPDATED_AT_DEFAULT_KEY;\n    var modelAttributes = (_a = this.schema.namespaces[USER].models[model].attributes) === null || _a === void 0 ? void 0 : _a.find(function (attr) {\n      return attr.type === 'model';\n    });\n    var timestampFieldsMap = (_b = modelAttributes === null || modelAttributes === void 0 ? void 0 : modelAttributes.properties) === null || _b === void 0 ? void 0 : _b.timestamps;\n    if (timestampFieldsMap) {\n      createdTimestampKey = timestampFieldsMap[CREATED_AT_DEFAULT_KEY];\n      updatedTimestampKey = timestampFieldsMap[UPDATED_AT_DEFAULT_KEY];\n    }\n    delete record[createdTimestampKey];\n    delete record[updatedTimestampKey];\n    return record;\n  };\n  return MutationEventOutbox;\n}();\nexport { MutationEventOutbox };","map":{"version":3,"mappings":"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","names":["ModelPredicateCreator","QueryOne","USER","SYNC","valuesEqual","getIdentifierValue","TransformerMutationType","schema","MutationEvent","modelInstanceCreator","ownSymbol","MutationEventOutbox","storage","mutationEvent","runExclusive","s","mutationEventModelDefinition","namespaces","models","predicate","createFromExisting","modelId","id","_this","inProgressMutationEventId","query","_a","_b","first","undefined","save","incomingMutationType","operation","CREATE","DELETE","delete","merged_1","mergeUserFields","copyOf","draft","data","incomingConditionJSON","incomingCondition","JSON","parse","merged","Object","keys","length","record","recordOp","peek","head","syncOutboxVersionsOnDequeue","queryOne","FIRST","model","userModelDefinition","mutationEvents","result","Set","forEach","add","_version","_lastChangedAt","_deleted","_incomingData","incomingData","removeTimestampFields","__version","__lastChangedAt","__deleted","_outgoingData","outgoingData","recordId","outdatedMutations","reconciledMutations","map","oldData","m","newData","stringify","Promise","all","previous","current","previousData","currentData","CREATED_AT_DEFAULT_KEY","UPDATED_AT_DEFAULT_KEY","createdTimestampKey","updatedTimestampKey","modelAttributes","attributes","find","type","timestampFieldsMap","properties","timestamps"],"sources":["/frontend-react-js/node_modules/@aws-amplify/datastore/src/sync/outbox.ts"],"sourcesContent":["import { MutationEvent } from './index';\nimport { ModelPredicateCreator } from '../predicates';\nimport {\n\tExclusiveStorage as Storage,\n\tStorageFacade,\n\tStorage as StorageClass,\n} from '../storage/storage';\nimport { ModelInstanceCreator } from '../datastore/datastore';\nimport {\n\tInternalSchema,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tQueryOne,\n\tSchemaModel,\n} from '../types';\nimport { USER, SYNC, valuesEqual } from '../util';\nimport { getIdentifierValue, TransformerMutationType } from './utils';\n\n// TODO: Persist deleted ids\n// https://github.com/aws-amplify/amplify-js/blob/datastore-docs/packages/datastore/docs/sync-engine.md#outbox\nclass MutationEventOutbox {\n\tprivate inProgressMutationEventId!: string;\n\n\tconstructor(\n\t\tprivate readonly schema: InternalSchema,\n\t\tprivate readonly MutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\tprivate readonly modelInstanceCreator: ModelInstanceCreator,\n\t\tprivate readonly ownSymbol: Symbol\n\t) {}\n\n\tpublic async enqueue(\n\t\tstorage: Storage,\n\t\tmutationEvent: MutationEvent\n\t): Promise<void> {\n\t\tawait storage.runExclusive(async s => {\n\t\t\tconst mutationEventModelDefinition =\n\t\t\t\tthis.schema.namespaces[SYNC].models['MutationEvent'];\n\n\t\t\t// `id` is the key for the record in the mutationEvent;\n\t\t\t// `modelId` is the key for the actual record that was mutated\n\t\t\tconst predicate = ModelPredicateCreator.createFromExisting<MutationEvent>(\n\t\t\t\tmutationEventModelDefinition,\n\t\t\t\tc =>\n\t\t\t\t\tc\n\t\t\t\t\t\t.modelId('eq', mutationEvent.modelId)\n\t\t\t\t\t\t.id('ne', this.inProgressMutationEventId)\n\t\t\t);\n\n\t\t\t// Check if there are any other records with same id\n\t\t\tconst [first] = await s.query(this.MutationEvent, predicate);\n\n\t\t\t// No other record with same modelId, so enqueue\n\t\t\tif (first === undefined) {\n\t\t\t\tawait s.save(mutationEvent, undefined, this.ownSymbol);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// There was an enqueued mutation for the modelId, so continue\n\t\t\tconst { operation: incomingMutationType } = mutationEvent;\n\n\t\t\tif (first.operation === TransformerMutationType.CREATE) {\n\t\t\t\tif (incomingMutationType === TransformerMutationType.DELETE) {\n\t\t\t\t\tawait s.delete(this.MutationEvent, predicate);\n\t\t\t\t} else {\n\t\t\t\t\t// first gets updated with the incoming mutation's data, condition intentionally skipped\n\n\t\t\t\t\t// we need to merge the fields for a create and update mutation to prevent\n\t\t\t\t\t// data loss, since update mutations only include changed fields\n\t\t\t\t\tconst merged = this.mergeUserFields(first, mutationEvent);\n\t\t\t\t\tawait s.save(\n\t\t\t\t\t\tthis.MutationEvent.copyOf(first, draft => {\n\t\t\t\t\t\t\tdraft.data = merged.data;\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tthis.ownSymbol\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst { condition: incomingConditionJSON } = mutationEvent;\n\t\t\t\tconst incomingCondition = JSON.parse(incomingConditionJSON);\n\t\t\t\tlet merged: MutationEvent;\n\n\t\t\t\t// If no condition\n\t\t\t\tif (Object.keys(incomingCondition).length === 0) {\n\t\t\t\t\tmerged = this.mergeUserFields(first, mutationEvent);\n\n\t\t\t\t\t// delete all for model\n\t\t\t\t\tawait s.delete(this.MutationEvent, predicate);\n\t\t\t\t}\n\n\t\t\t\tmerged = merged! || mutationEvent;\n\n\t\t\t\t// Enqueue new one\n\t\t\t\tawait s.save(merged, undefined, this.ownSymbol);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async dequeue(\n\t\tstorage: StorageClass,\n\t\trecord?: PersistentModel,\n\t\trecordOp?: TransformerMutationType\n\t): Promise<MutationEvent> {\n\t\tconst head = await this.peek(storage);\n\n\t\tif (record) {\n\t\t\tawait this.syncOutboxVersionsOnDequeue(storage, record, head, recordOp!);\n\t\t}\n\n\t\tawait storage.delete(head);\n\t\tthis.inProgressMutationEventId = undefined!;\n\n\t\treturn head;\n\t}\n\n\t/**\n\t * Doing a peek() implies that the mutation goes \"inProgress\"\n\t *\n\t * @param storage\n\t */\n\tpublic async peek(storage: StorageFacade): Promise<MutationEvent> {\n\t\tconst head = await storage.queryOne(this.MutationEvent, QueryOne.FIRST);\n\n\t\tthis.inProgressMutationEventId = head ? head.id : undefined!;\n\n\t\treturn head!;\n\t}\n\n\tpublic async getForModel<T extends PersistentModel>(\n\t\tstorage: StorageFacade,\n\t\tmodel: T,\n\t\tuserModelDefinition: SchemaModel\n\t): Promise<MutationEvent[]> {\n\t\tconst mutationEventModelDefinition =\n\t\t\tthis.schema.namespaces[SYNC].models.MutationEvent;\n\n\t\tconst modelId = getIdentifierValue(userModelDefinition, model);\n\n\t\tconst mutationEvents = await storage.query(\n\t\t\tthis.MutationEvent,\n\t\t\tModelPredicateCreator.createFromExisting(\n\t\t\t\tmutationEventModelDefinition,\n\t\t\t\tc => c.modelId('eq', modelId)\n\t\t\t)\n\t\t);\n\n\t\treturn mutationEvents;\n\t}\n\n\tpublic async getModelIds(storage: StorageFacade): Promise<Set<string>> {\n\t\tconst mutationEvents = await storage.query(this.MutationEvent);\n\n\t\tconst result = new Set<string>();\n\n\t\tmutationEvents.forEach(({ modelId }) => result.add(modelId));\n\n\t\treturn result;\n\t}\n\n\t// applies _version from the AppSync mutation response to other items\n\t// in the mutation queue with the same id\n\t// see https://github.com/aws-amplify/amplify-js/pull/7354 for more details\n\tprivate async syncOutboxVersionsOnDequeue(\n\t\tstorage: StorageClass,\n\t\trecord: PersistentModel,\n\t\thead: PersistentModel,\n\t\trecordOp: string\n\t): Promise<void> {\n\t\tif (head.operation !== recordOp) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { _version, _lastChangedAt, _deleted, ..._incomingData } = record;\n\t\tconst incomingData = this.removeTimestampFields(head.model, _incomingData);\n\n\t\tconst data = JSON.parse(head.data);\n\n\t\tif (!data) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst {\n\t\t\t_version: __version,\n\t\t\t_lastChangedAt: __lastChangedAt,\n\t\t\t_deleted: __deleted,\n\t\t\t..._outgoingData\n\t\t} = data;\n\t\tconst outgoingData = this.removeTimestampFields(head.model, _outgoingData);\n\n\t\t// Don't sync the version when the data in the response does not match the data\n\t\t// in the request, i.e., when there's a handled conflict\n\t\tif (!valuesEqual(incomingData, outgoingData, true)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mutationEventModelDefinition =\n\t\t\tthis.schema.namespaces[SYNC].models['MutationEvent'];\n\n\t\tconst userModelDefinition =\n\t\t\tthis.schema.namespaces['user'].models[head.model];\n\n\t\tconst recordId = getIdentifierValue(userModelDefinition, record);\n\n\t\tconst predicate = ModelPredicateCreator.createFromExisting<MutationEvent>(\n\t\t\tmutationEventModelDefinition,\n\t\t\tc => c.modelId('eq', recordId).id('ne', this.inProgressMutationEventId)\n\t\t);\n\n\t\tconst outdatedMutations = await storage.query(\n\t\t\tthis.MutationEvent,\n\t\t\tpredicate\n\t\t);\n\n\t\tif (!outdatedMutations.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst reconciledMutations = outdatedMutations.map(m => {\n\t\t\tconst oldData = JSON.parse(m.data);\n\n\t\t\tconst newData = { ...oldData, _version, _lastChangedAt };\n\n\t\t\treturn this.MutationEvent.copyOf(m, draft => {\n\t\t\t\tdraft.data = JSON.stringify(newData);\n\t\t\t});\n\t\t});\n\n\t\tawait storage.delete(this.MutationEvent, predicate);\n\n\t\tawait Promise.all(\n\t\t\treconciledMutations.map(\n\t\t\t\tasync m => await storage.save(m, undefined, this.ownSymbol)\n\t\t\t)\n\t\t);\n\t}\n\n\tprivate mergeUserFields(\n\t\tprevious: MutationEvent,\n\t\tcurrent: MutationEvent\n\t): MutationEvent {\n\t\tconst { _version, _lastChangedAt, _deleted, ...previousData } = JSON.parse(\n\t\t\tprevious.data\n\t\t);\n\n\t\tconst {\n\t\t\t_version: __version,\n\t\t\t_lastChangedAt: __lastChangedAt,\n\t\t\t_deleted: __deleted,\n\t\t\t...currentData\n\t\t} = JSON.parse(current.data);\n\n\t\tconst data = JSON.stringify({\n\t\t\t_version,\n\t\t\t_lastChangedAt,\n\t\t\t_deleted,\n\t\t\t...previousData,\n\t\t\t...currentData,\n\t\t});\n\n\t\treturn this.modelInstanceCreator(this.MutationEvent, {\n\t\t\t...current,\n\t\t\tdata,\n\t\t});\n\t}\n\n\t/* \n\tif a model is using custom timestamp fields\n\tthe custom field names will be stored in the model attributes\n\n\te.g.\n\t\"attributes\": [\n    {\n\t\t\t\"type\": \"model\",\n\t\t\t\"properties\": {\n\t\t\t\t\"timestamps\": {\n\t\t\t\t\t\"createdAt\": \"createdOn\",\n\t\t\t\t\t\"updatedAt\": \"updatedOn\"\n\t\t\t\t}\n\t\t\t}\n    }\n\t]\n\t*/\n\tprivate removeTimestampFields(\n\t\tmodel: string,\n\t\trecord: PersistentModel\n\t): PersistentModel {\n\t\tconst CREATED_AT_DEFAULT_KEY = 'createdAt';\n\t\tconst UPDATED_AT_DEFAULT_KEY = 'updatedAt';\n\n\t\tlet createdTimestampKey = CREATED_AT_DEFAULT_KEY;\n\t\tlet updatedTimestampKey = UPDATED_AT_DEFAULT_KEY;\n\n\t\tconst modelAttributes = this.schema.namespaces[USER].models[\n\t\t\tmodel\n\t\t].attributes?.find(attr => attr.type === 'model');\n\t\tconst timestampFieldsMap = modelAttributes?.properties?.timestamps;\n\n\t\tif (timestampFieldsMap) {\n\t\t\tcreatedTimestampKey = timestampFieldsMap[CREATED_AT_DEFAULT_KEY];\n\t\t\tupdatedTimestampKey = timestampFieldsMap[UPDATED_AT_DEFAULT_KEY];\n\t\t}\n\n\t\tdelete (record as Record<string, any>)[createdTimestampKey];\n\t\tdelete (record as Record<string, any>)[updatedTimestampKey];\n\n\t\treturn record;\n\t}\n}\n\nexport { MutationEventOutbox };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}