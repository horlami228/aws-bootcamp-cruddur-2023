{"ast":null,"code":"import { __awaiter, __extends, __generator, __read, __spread } from \"tslib\";\nimport { ConsoleLogger as Logger } from '../Logger/ConsoleLogger';\nvar logger = new Logger('Util');\nvar NonRetryableError = /** @class */function (_super) {\n  __extends(NonRetryableError, _super);\n  function NonRetryableError(message) {\n    var _this = _super.call(this, message) || this;\n    _this.nonRetryable = true;\n    return _this;\n  }\n  return NonRetryableError;\n}(Error);\nexport { NonRetryableError };\nexport var isNonRetryableError = function (obj) {\n  var key = 'nonRetryable';\n  return obj && obj[key];\n};\n/**\n * @private\n * Internal use of Amplify only\n */\nexport function retry(functionToRetry, args, delayFn, onTerminate) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _this = this;\n    return __generator(this, function (_a) {\n      if (typeof functionToRetry !== 'function') {\n        throw Error('functionToRetry must be a function');\n      }\n      return [2 /*return*/, new Promise(function (resolve, reject) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var attempt, terminated, timeout, wakeUp, lastError, _loop_1, state_1;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                attempt = 0;\n                terminated = false;\n                wakeUp = function () {};\n                onTerminate && onTerminate.then(function () {\n                  // signal not to try anymore.\n                  terminated = true;\n                  // stop sleeping if we're sleeping.\n                  clearTimeout(timeout);\n                  wakeUp();\n                });\n                _loop_1 = function () {\n                  var _a, _b, err_1, retryIn_1;\n                  return __generator(this, function (_c) {\n                    switch (_c.label) {\n                      case 0:\n                        attempt++;\n                        logger.debug(functionToRetry.name + \" attempt #\" + attempt + \" with this vars: \" + JSON.stringify(args));\n                        _c.label = 1;\n                      case 1:\n                        _c.trys.push([1, 3,, 7]);\n                        _a = {};\n                        _b = resolve;\n                        return [4 /*yield*/, functionToRetry.apply(void 0, __spread(args))];\n                      case 2:\n                        return [2 /*return*/, (_a.value = _b.apply(void 0, [_c.sent()]), _a)];\n                      case 3:\n                        err_1 = _c.sent();\n                        lastError = err_1;\n                        logger.debug(\"error on \" + functionToRetry.name, err_1);\n                        if (isNonRetryableError(err_1)) {\n                          logger.debug(functionToRetry.name + \" non retryable error\", err_1);\n                          return [2 /*return*/, {\n                            value: reject(err_1)\n                          }];\n                        }\n                        retryIn_1 = delayFn(attempt, args, err_1);\n                        logger.debug(functionToRetry.name + \" retrying in \" + retryIn_1 + \" ms\");\n                        if (!(retryIn_1 === false || terminated)) return [3 /*break*/, 4];\n                        return [2 /*return*/, {\n                          value: reject(err_1)\n                        }];\n                      case 4:\n                        return [4 /*yield*/, new Promise(function (r) {\n                          wakeUp = r; // export wakeUp for onTerminate handling\n                          timeout = setTimeout(wakeUp, retryIn_1);\n                        })];\n                      case 5:\n                        _c.sent();\n                        _c.label = 6;\n                      case 6:\n                        return [3 /*break*/, 7];\n                      case 7:\n                        return [2 /*return*/];\n                    }\n                  });\n                };\n\n                _a.label = 1;\n              case 1:\n                if (!!terminated) return [3 /*break*/, 3];\n                return [5 /*yield**/, _loop_1()];\n              case 2:\n                state_1 = _a.sent();\n                if (typeof state_1 === \"object\") return [2 /*return*/, state_1.value];\n                return [3 /*break*/, 1];\n              case 3:\n                // reached if terminated while waiting for a timer.\n                reject(lastError);\n                return [2 /*return*/];\n            }\n          });\n        });\n      })];\n    });\n  });\n}\n\nvar MAX_DELAY_MS = 5 * 60 * 1000;\n/**\n * @private\n * Internal use of Amplify only\n */\nexport function jitteredBackoff(maxDelayMs) {\n  if (maxDelayMs === void 0) {\n    maxDelayMs = MAX_DELAY_MS;\n  }\n  var BASE_TIME_MS = 100;\n  var JITTER_FACTOR = 100;\n  return function (attempt) {\n    var delay = Math.pow(2, attempt) * BASE_TIME_MS + JITTER_FACTOR * Math.random();\n    return delay > maxDelayMs ? false : delay;\n  };\n}\n/**\n * @private\n * Internal use of Amplify only\n */\nexport var jitteredExponentialRetry = function (functionToRetry, args, maxDelayMs, onTerminate) {\n  if (maxDelayMs === void 0) {\n    maxDelayMs = MAX_DELAY_MS;\n  }\n  return retry(functionToRetry, args, jitteredBackoff(maxDelayMs), onTerminate);\n};","map":{"version":3,"mappings":";AACA,SAASA,aAAa,IAAIC,MAAM,QAAQ,yBAAyB;AACjE,IAAMC,MAAM,GAAG,IAAID,MAAM,CAAC,MAAM,CAAC;AAEjC;EAAuCE;EAEtC,2BAAYC,OAAe;IAA3B,YACCC,kBAAMD,OAAO,CAAC;IAFCE,kBAAY,GAAG,IAAI;;EAGnC;EACD,wBAAC;AAAD,CAAC,CALsCC,KAAK;;AAO5C,OAAO,IAAMC,mBAAmB,GAAG,UAACC,GAAQ;EAC3C,IAAMC,GAAG,GAA4B,cAAc;EACnD,OAAOD,GAAG,IAAIA,GAAG,CAACC,GAAG,CAAC;AACvB,CAAC;AAED;;;;AAIA,OAAM,SAAgBC,KAAK,CAC1BC,eAAsC,EACtCC,IAAW,EACXC,OAAsB,EACtBC,WAA2B;;;;MAE3B,IAAI,OAAOH,eAAe,KAAK,UAAU,EAAE;QAC1C,MAAML,KAAK,CAAC,oCAAoC,CAAC;;MAGlD,sBAAO,IAAIS,OAAO,CAAC,UAAOC,OAAO,EAAEC,MAAM;QAAA;;;;;gBACpCC,OAAO,GAAG,CAAC;gBACXC,UAAU,GAAG,KAAK;gBAElBC,MAAM,GAAQ,aAAO,CAAC;gBAK1BN,WAAW,IACVA,WAAW,CAACO,IAAI,CAAC;kBAChB;kBACAF,UAAU,GAAG,IAAI;kBAEjB;kBACAG,YAAY,CAACC,OAAO,CAAC;kBACrBH,MAAM,EAAE;gBACT,CAAC,CAAC;;;;;;wBAGFF,OAAO,EAAE;wBAETjB,MAAM,CAACuB,KAAK,CAEVb,eAAe,CAACc,IAAI,kBACRP,OAAO,yBAAoBQ,IAAI,CAACC,SAAS,CAACf,IAAI,CAAG,CAC9D;;;;;wBAGOgB,YAAO;wBAAC,qBAAMjB,eAAe,wBAAIC,IAAI;;0DAArCgB,kBAAQC,SAA8B,EAAC;;;wBAE9CC,SAAS,GAAGC,KAAG;wBACf9B,MAAM,CAACuB,KAAK,CAAC,cAAYb,eAAe,CAACc,IAAM,EAAEM,KAAG,CAAC;wBAErD,IAAIxB,mBAAmB,CAACwB,KAAG,CAAC,EAAE;0BAC7B9B,MAAM,CAACuB,KAAK,CAAIb,eAAe,CAACc,IAAI,yBAAsB,EAAEM,KAAG,CAAC;;mCACzDd,MAAM,CAACc,KAAG;0BAAC;;wBAGbC,YAAUnB,OAAO,CAACK,OAAO,EAAEN,IAAI,EAAEmB,KAAG,CAAC;wBAC3C9B,MAAM,CAACuB,KAAK,CAAIb,eAAe,CAACc,IAAI,qBAAgBO,SAAO,QAAK,CAAC;8BAI7DA,SAAO,KAAK,KAAK,IAAIb,UAAU,GAA/B;;iCACIF,MAAM,CAACc,KAAG;wBAAC;;wBAElB,qBAAM,IAAIhB,OAAO,CAAC,WAAC;0BAClBK,MAAM,GAAGa,CAAC,CAAC,CAAC;0BACZV,OAAO,GAAGW,UAAU,CAACd,MAAM,EAAEY,SAAO,CAAC;wBACtC,CAAC,CAAC;;wBAHFH,SAGE;;;;;;;;;;;;qBA/BE,CAACV,UAAU;;;;;;;gBAoClB;gBACAF,MAAM,CAACa,SAAS,CAAC;;;;;OACjB,CAAC;;;;;AAGH,IAAMK,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI;AAElC;;;;AAIA,OAAM,SAAUC,eAAe,CAC9BC,UAAiC;EAAjC;IAAAA,yBAAiC;EAAA;EAEjC,IAAMC,YAAY,GAAG,GAAG;EACxB,IAAMC,aAAa,GAAG,GAAG;EAEzB,OAAO,iBAAO;IACb,IAAMC,KAAK,GAAGC,UAAC,EAAIvB,OAAO,IAAGoB,YAAY,GAAGC,aAAa,GAAGE,IAAI,CAACC,MAAM,EAAE;IACzE,OAAOF,KAAK,GAAGH,UAAU,GAAG,KAAK,GAAGG,KAAK;EAC1C,CAAC;AACF;AAEA;;;;AAIA,OAAO,IAAMG,wBAAwB,GAAG,UACvChC,eAAsC,EACtCC,IAAW,EACXyB,UAAiC,EACjCvB,WAA2B;EAD3B;IAAAuB,yBAAiC;EAAA;EAGjC,YAAK,CAAC1B,eAAe,EAAEC,IAAI,EAAEwB,eAAe,CAACC,UAAU,CAAC,EAAEvB,WAAW,CAAC;AAAtE,CAAsE","names":["ConsoleLogger","Logger","logger","__extends","message","_super","_this","Error","isNonRetryableError","obj","key","retry","functionToRetry","args","delayFn","onTerminate","Promise","resolve","reject","attempt","terminated","wakeUp","then","clearTimeout","timeout","debug","name","JSON","stringify","_b","_c","lastError","err_1","retryIn_1","r","setTimeout","MAX_DELAY_MS","jitteredBackoff","maxDelayMs","BASE_TIME_MS","JITTER_FACTOR","delay","Math","random","jitteredExponentialRetry"],"sources":["/frontend-react-js/node_modules/@aws-amplify/core/src/Util/Retry.ts"],"sourcesContent":["import { DelayFunction } from '../types';\nimport { ConsoleLogger as Logger } from '../Logger/ConsoleLogger';\nconst logger = new Logger('Util');\n\nexport class NonRetryableError extends Error {\n\tpublic readonly nonRetryable = true;\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t}\n}\n\nexport const isNonRetryableError = (obj: any): obj is NonRetryableError => {\n\tconst key: keyof NonRetryableError = 'nonRetryable';\n\treturn obj && obj[key];\n};\n\n/**\n * @private\n * Internal use of Amplify only\n */\nexport async function retry<T>(\n\tfunctionToRetry: (...args: any[]) => T,\n\targs: any[],\n\tdelayFn: DelayFunction,\n\tonTerminate?: Promise<void>\n): Promise<T> {\n\tif (typeof functionToRetry !== 'function') {\n\t\tthrow Error('functionToRetry must be a function');\n\t}\n\n\treturn new Promise(async (resolve, reject) => {\n\t\tlet attempt = 0;\n\t\tlet terminated = false;\n\t\tlet timeout: any;\n\t\tlet wakeUp: any = () => {}; // will be replaced with a resolver()\n\n\t\t// used after the loop if terminated while waiting for a timer.\n\t\tlet lastError: Error;\n\n\t\tonTerminate &&\n\t\t\tonTerminate.then(() => {\n\t\t\t\t// signal not to try anymore.\n\t\t\t\tterminated = true;\n\n\t\t\t\t// stop sleeping if we're sleeping.\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\twakeUp();\n\t\t\t});\n\n\t\twhile (!terminated) {\n\t\t\tattempt++;\n\n\t\t\tlogger.debug(\n\t\t\t\t`${\n\t\t\t\t\tfunctionToRetry.name\n\t\t\t\t} attempt #${attempt} with this vars: ${JSON.stringify(args)}`\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\treturn resolve(await functionToRetry(...args));\n\t\t\t} catch (err) {\n\t\t\t\tlastError = err;\n\t\t\t\tlogger.debug(`error on ${functionToRetry.name}`, err);\n\n\t\t\t\tif (isNonRetryableError(err)) {\n\t\t\t\t\tlogger.debug(`${functionToRetry.name} non retryable error`, err);\n\t\t\t\t\treturn reject(err);\n\t\t\t\t}\n\n\t\t\t\tconst retryIn = delayFn(attempt, args, err);\n\t\t\t\tlogger.debug(`${functionToRetry.name} retrying in ${retryIn} ms`);\n\n\t\t\t\t// we check `terminated` again here because it could have flipped\n\t\t\t\t// in the time it took `functionToRetry` to return.\n\t\t\t\tif (retryIn === false || terminated) {\n\t\t\t\t\treturn reject(err);\n\t\t\t\t} else {\n\t\t\t\t\tawait new Promise(r => {\n\t\t\t\t\t\twakeUp = r; // export wakeUp for onTerminate handling\n\t\t\t\t\t\ttimeout = setTimeout(wakeUp, retryIn);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// reached if terminated while waiting for a timer.\n\t\treject(lastError);\n\t});\n}\n\nconst MAX_DELAY_MS = 5 * 60 * 1000;\n\n/**\n * @private\n * Internal use of Amplify only\n */\nexport function jitteredBackoff(\n\tmaxDelayMs: number = MAX_DELAY_MS\n): DelayFunction {\n\tconst BASE_TIME_MS = 100;\n\tconst JITTER_FACTOR = 100;\n\n\treturn attempt => {\n\t\tconst delay = 2 ** attempt * BASE_TIME_MS + JITTER_FACTOR * Math.random();\n\t\treturn delay > maxDelayMs ? false : delay;\n\t};\n}\n\n/**\n * @private\n * Internal use of Amplify only\n */\nexport const jitteredExponentialRetry = <T>(\n\tfunctionToRetry: (...args: any[]) => T,\n\targs: any[],\n\tmaxDelayMs: number = MAX_DELAY_MS,\n\tonTerminate?: Promise<void>\n): Promise<T> =>\n\tretry(functionToRetry, args, jitteredBackoff(maxDelayMs), onTerminate);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}