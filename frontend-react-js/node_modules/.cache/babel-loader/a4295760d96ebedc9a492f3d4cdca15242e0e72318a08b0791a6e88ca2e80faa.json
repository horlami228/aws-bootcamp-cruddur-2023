{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __rest, __values } from \"tslib\";\nimport { API } from '@aws-amplify/api';\nimport { ConsoleLogger as Logger, jitteredBackoff, NonRetryableError, retry, BackgroundProcessManager } from '@aws-amplify/core';\nimport Observable from 'zen-observable-ts';\nimport { DISCARD, isModelFieldType, isTargetNameAssociation, OpType, ProcessName } from '../../types';\nimport { extractTargetNamesFromSrc, USER, USER_AGENT_SUFFIX_DATASTORE, ID } from '../../util';\nimport { buildGraphQLOperation, createMutationInstanceFromModelOperation, getModelAuthModes, TransformerMutationType, getTokenForCustomAuth } from '../utils';\nimport { getMutationErrorType } from './errorMaps';\nvar MAX_ATTEMPTS = 10;\nvar logger = new Logger('DataStore');\nvar MutationProcessor = /** @class */function () {\n  function MutationProcessor(schema, storage, userClasses, outbox, modelInstanceCreator, MutationEvent, amplifyConfig, authModeStrategy, errorHandler, conflictHandler, amplifyContext) {\n    if (amplifyConfig === void 0) {\n      amplifyConfig = {};\n    }\n    this.schema = schema;\n    this.storage = storage;\n    this.userClasses = userClasses;\n    this.outbox = outbox;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.MutationEvent = MutationEvent;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.errorHandler = errorHandler;\n    this.conflictHandler = conflictHandler;\n    this.amplifyContext = amplifyContext;\n    this.typeQuery = new WeakMap();\n    this.processing = false;\n    this.runningProcesses = new BackgroundProcessManager();\n    this.amplifyContext.API = this.amplifyContext.API || API;\n    this.generateQueries();\n  }\n  MutationProcessor.prototype.generateQueries = function () {\n    var _this = this;\n    Object.values(this.schema.namespaces).forEach(function (namespace) {\n      Object.values(namespace.models).filter(function (_a) {\n        var syncable = _a.syncable;\n        return syncable;\n      }).forEach(function (model) {\n        var _a = __read(buildGraphQLOperation(namespace, model, 'CREATE'), 1),\n          createMutation = _a[0];\n        var _b = __read(buildGraphQLOperation(namespace, model, 'UPDATE'), 1),\n          updateMutation = _b[0];\n        var _c = __read(buildGraphQLOperation(namespace, model, 'DELETE'), 1),\n          deleteMutation = _c[0];\n        _this.typeQuery.set(model, [createMutation, updateMutation, deleteMutation]);\n      });\n    });\n  };\n  MutationProcessor.prototype.isReady = function () {\n    return this.observer !== undefined;\n  };\n  MutationProcessor.prototype.start = function () {\n    var _this = this;\n    this.runningProcesses = new BackgroundProcessManager();\n    var observable = new Observable(function (observer) {\n      _this.observer = observer;\n      try {\n        _this.resume();\n      } catch (error) {\n        logger.error('mutations processor start error', error);\n        throw error;\n      }\n      return _this.runningProcesses.addCleaner(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            this.pause();\n            return [2 /*return*/];\n          });\n        });\n      });\n    });\n\n    return observable;\n  };\n  MutationProcessor.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 1:\n            _a.sent();\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 2:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationProcessor.prototype.resume = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.runningProcesses.isOpen && this.runningProcesses.add(function (onTerminate) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var head, namespaceName, _loop_1, this_1, _a;\n                var _this = this;\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      if (this.processing || !this.isReady() || !this.runningProcesses.isOpen) {\n                        return [2 /*return*/];\n                      }\n\n                      this.processing = true;\n                      namespaceName = USER;\n                      _loop_1 = function () {\n                        var model, operation, data, condition, modelConstructor, result, opName, modelDefinition, modelAuthModes, operationAuthModes_1, authModeAttempts_1, authModeRetry_1, error_1, record, hasMore;\n                        var _a;\n                        return __generator(this, function (_b) {\n                          switch (_b.label) {\n                            case 0:\n                              model = head.model, operation = head.operation, data = head.data, condition = head.condition;\n                              modelConstructor = this_1.userClasses[model];\n                              result = undefined;\n                              opName = undefined;\n                              modelDefinition = undefined;\n                              _b.label = 1;\n                            case 1:\n                              _b.trys.push([1, 4,, 5]);\n                              return [4 /*yield*/, getModelAuthModes({\n                                authModeStrategy: this_1.authModeStrategy,\n                                defaultAuthMode: this_1.amplifyConfig.aws_appsync_authenticationType,\n                                modelName: model,\n                                schema: this_1.schema\n                              })];\n                            case 2:\n                              modelAuthModes = _b.sent();\n                              operationAuthModes_1 = modelAuthModes[operation.toUpperCase()];\n                              authModeAttempts_1 = 0;\n                              authModeRetry_1 = function () {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  var response, error_2;\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        _a.trys.push([0, 2,, 4]);\n                                        logger.debug(\"Attempting mutation with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [4 /*yield*/, this.jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, this.MutationEvent, head, operationAuthModes_1[authModeAttempts_1], onTerminate)];\n                                      case 1:\n                                        response = _a.sent();\n                                        logger.debug(\"Mutation sent successfully with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [2 /*return*/, response];\n                                      case 2:\n                                        error_2 = _a.sent();\n                                        authModeAttempts_1++;\n                                        if (authModeAttempts_1 >= operationAuthModes_1.length) {\n                                          logger.debug(\"Mutation failed with authMode: \" + operationAuthModes_1[authModeAttempts_1 - 1]);\n                                          throw error_2;\n                                        }\n                                        logger.debug(\"Mutation failed with authMode: \" + operationAuthModes_1[authModeAttempts_1 - 1] + \". Retrying with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [4 /*yield*/, authModeRetry_1()];\n                                      case 3:\n                                        return [2 /*return*/, _a.sent()];\n                                      case 4:\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              };\n\n                              return [4 /*yield*/, authModeRetry_1()];\n                            case 3:\n                              _a = __read.apply(void 0, [_b.sent(), 3]), result = _a[0], opName = _a[1], modelDefinition = _a[2];\n                              return [3 /*break*/, 5];\n                            case 4:\n                              error_1 = _b.sent();\n                              if (error_1.message === 'Offline' || error_1.message === 'RetryMutation') {\n                                return [2 /*return*/, \"continue\"];\n                              }\n                              return [3 /*break*/, 5];\n                            case 5:\n                              if (!(result === undefined)) return [3 /*break*/, 7];\n                              logger.debug('done retrying');\n                              return [4 /*yield*/, this_1.storage.runExclusive(function (storage) {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        return [4 /*yield*/, this.outbox.dequeue(storage)];\n                                      case 1:\n                                        _a.sent();\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              })];\n\n                            case 6:\n                              _b.sent();\n                              return [2 /*return*/, \"continue\"];\n                            case 7:\n                              record = result.data[opName];\n                              hasMore = false;\n                              return [4 /*yield*/, this_1.storage.runExclusive(function (storage) {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        // using runExclusive to prevent possible race condition\n                                        // when another record gets enqueued between dequeue and peek\n                                        return [4 /*yield*/, this.outbox.dequeue(storage, record, operation)];\n                                      case 1:\n                                        // using runExclusive to prevent possible race condition\n                                        // when another record gets enqueued between dequeue and peek\n                                        _a.sent();\n                                        return [4 /*yield*/, this.outbox.peek(storage)];\n                                      case 2:\n                                        hasMore = _a.sent() !== undefined;\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              })];\n\n                            case 8:\n                              _b.sent();\n                              this_1.observer.next({\n                                operation: operation,\n                                modelDefinition: modelDefinition,\n                                model: record,\n                                hasMore: hasMore\n                              });\n                              return [2 /*return*/];\n                          }\n                        });\n                      };\n\n                      this_1 = this;\n                      _b.label = 1;\n                    case 1:\n                      _a = this.processing && this.runningProcesses.isOpen;\n                      if (!_a) return [3 /*break*/, 3];\n                      return [4 /*yield*/, this.outbox.peek(this.storage)];\n                    case 2:\n                      _a = (head = _b.sent()) !== undefined;\n                      _b.label = 3;\n                    case 3:\n                      if (!_a) return [3 /*break*/, 5];\n                      return [5 /*yield**/, _loop_1()];\n                    case 4:\n                      _b.sent();\n                      return [3 /*break*/, 1];\n                    case 5:\n                      // pauses itself\n                      this.pause();\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            }, 'mutation resume loop')];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationProcessor.prototype.jitteredRetry = function (namespaceName, model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent, authMode, onTerminate) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, retry(function (model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var _a, query, variables, graphQLCondition, opName, modelDefinition, authToken, tryWith, attempt, opType, result, err_1, _b, error, _c, _d, code, retryWith, err_2, _e, _f, opName_1, query_1, authToken_1, serverData, namespace, updatedMutation;\n                var _g;\n                return __generator(this, function (_h) {\n                  switch (_h.label) {\n                    case 0:\n                      _a = __read(this.createQueryVariables(namespaceName, model, operation, data, condition), 5), query = _a[0], variables = _a[1], graphQLCondition = _a[2], opName = _a[3], modelDefinition = _a[4];\n                      return [4 /*yield*/, getTokenForCustomAuth(authMode, this.amplifyConfig)];\n                    case 1:\n                      authToken = _h.sent();\n                      tryWith = {\n                        query: query,\n                        variables: variables,\n                        authMode: authMode,\n                        authToken: authToken,\n                        userAgentSuffix: USER_AGENT_SUFFIX_DATASTORE\n                      };\n                      attempt = 0;\n                      opType = this.opTypeFromTransformerOperation(operation);\n                      _h.label = 2;\n                    case 2:\n                      _h.trys.push([2, 4,, 17]);\n                      return [4 /*yield*/, this.amplifyContext.API.graphql(tryWith)];\n                    case 3:\n                      result = _h.sent();\n                      // Use `as any` because TypeScript doesn't seem to like passing tuples\n                      // through generic params.\n                      return [2 /*return*/, [result, opName, modelDefinition]];\n                    case 4:\n                      err_1 = _h.sent();\n                      if (!(err_1.errors && err_1.errors.length > 0)) return [3 /*break*/, 15];\n                      _b = __read(err_1.errors, 1), error = _b[0];\n                      _c = error.originalError, _d = (_c === void 0 ? {} : _c).code, code = _d === void 0 ? null : _d;\n                      if (error.errorType === 'Unauthorized') {\n                        throw new NonRetryableError('Unauthorized');\n                      }\n                      if (error.message === 'Network Error' || code === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n                      ) {\n                        if (!this.processing) {\n                          throw new NonRetryableError('Offline');\n                        }\n                        // TODO: Check errors on different env (react-native or other browsers)\n                        throw new Error('Network Error');\n                      }\n                      if (!(error.errorType === 'ConflictUnhandled')) return [3 /*break*/, 13];\n                      // TODO: add on ConflictConditionalCheck error query last from server\n                      attempt++;\n                      retryWith = void 0;\n                      if (!(attempt > MAX_ATTEMPTS)) return [3 /*break*/, 5];\n                      retryWith = DISCARD;\n                      return [3 /*break*/, 8];\n                    case 5:\n                      _h.trys.push([5, 7,, 8]);\n                      return [4 /*yield*/, this.conflictHandler({\n                        modelConstructor: modelConstructor,\n                        localModel: this.modelInstanceCreator(modelConstructor, variables.input),\n                        remoteModel: this.modelInstanceCreator(modelConstructor, error.data),\n                        operation: opType,\n                        attempts: attempt\n                      })];\n                    case 6:\n                      retryWith = _h.sent();\n                      return [3 /*break*/, 8];\n                    case 7:\n                      err_2 = _h.sent();\n                      logger.warn('conflict trycatch', err_2);\n                      return [3 /*break*/, 17];\n                    case 8:\n                      if (!(retryWith === DISCARD)) return [3 /*break*/, 11];\n                      _e = __read(buildGraphQLOperation(this.schema.namespaces[namespaceName], modelDefinition, 'GET'), 1), _f = __read(_e[0], 3), opName_1 = _f[1], query_1 = _f[2];\n                      return [4 /*yield*/, getTokenForCustomAuth(authMode, this.amplifyConfig)];\n                    case 9:\n                      authToken_1 = _h.sent();\n                      return [4 /*yield*/, this.amplifyContext.API.graphql({\n                        query: query_1,\n                        variables: {\n                          id: variables.input.id\n                        },\n                        authMode: authMode,\n                        authToken: authToken_1,\n                        userAgentSuffix: USER_AGENT_SUFFIX_DATASTORE\n                      })];\n                    case 10:\n                      serverData = _h.sent();\n                      // onTerminate cancel graphql()\n                      return [2 /*return*/, [serverData, opName_1, modelDefinition]];\n                    case 11:\n                      namespace = this.schema.namespaces[namespaceName];\n                      updatedMutation = createMutationInstanceFromModelOperation(namespace.relationships, modelDefinition, opType, modelConstructor, retryWith, graphQLCondition, MutationEvent, this.modelInstanceCreator, mutationEvent.id);\n                      return [4 /*yield*/, this.storage.save(updatedMutation)];\n                    case 12:\n                      _h.sent();\n                      throw new NonRetryableError('RetryMutation');\n                    case 13:\n                      try {\n                        this.errorHandler({\n                          recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                          localModel: variables.input,\n                          message: error.message,\n                          operation: operation,\n                          errorType: getMutationErrorType(error),\n                          errorInfo: error.errorInfo,\n                          process: ProcessName.mutate,\n                          cause: error,\n                          remoteModel: error.data ? this.modelInstanceCreator(modelConstructor, error.data) : null\n                        });\n                      } catch (err) {\n                        logger.warn('Mutation error handler failed with:', err);\n                      } finally {\n                        // Return empty tuple, dequeues the mutation\n                        return [2 /*return*/, error.data ? [{\n                          data: (_g = {}, _g[opName] = error.data, _g)\n                        }, opName, modelDefinition] : []];\n                      }\n                      _h.label = 14;\n                    case 14:\n                      return [3 /*break*/, 16];\n                    case 15:\n                      // Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n                      // These errors should not be retried.\n                      throw new NonRetryableError(err_1);\n                    case 16:\n                      return [3 /*break*/, 17];\n                    case 17:\n                      if (tryWith) return [3 /*break*/, 2];\n                      _h.label = 18;\n                    case 18:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            }, [model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent], safeJitteredBackoff, onTerminate)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  MutationProcessor.prototype.createQueryVariables = function (namespaceName, model, operation, data, condition) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    var modelDefinition = this.schema.namespaces[namespaceName].models[model];\n    var primaryKey = this.schema.namespaces[namespaceName].keys[model].primaryKey;\n    var queriesTuples = this.typeQuery.get(modelDefinition);\n    var _d = __read(queriesTuples.find(function (_a) {\n        var _b = __read(_a, 1),\n          transformerMutationType = _b[0];\n        return transformerMutationType === operation;\n      }), 3),\n      opName = _d[1],\n      query = _d[2];\n    var _e = JSON.parse(data),\n      _version = _e._version,\n      parsedData = __rest(_e, [\"_version\"]);\n    // include all the fields that comprise a custom PK if one is specified\n    var deleteInput = {};\n    if (primaryKey === null || primaryKey === void 0 ? void 0 : primaryKey.length) {\n      try {\n        for (var primaryKey_1 = __values(primaryKey), primaryKey_1_1 = primaryKey_1.next(); !primaryKey_1_1.done; primaryKey_1_1 = primaryKey_1.next()) {\n          var pkField = primaryKey_1_1.value;\n          deleteInput[pkField] = parsedData[pkField];\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (primaryKey_1_1 && !primaryKey_1_1.done && (_a = primaryKey_1.return)) _a.call(primaryKey_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    } else {\n      deleteInput[ID] = parsedData.id;\n    }\n    var mutationInput;\n    if (operation === TransformerMutationType.DELETE) {\n      // For DELETE mutations, only the key(s) are included in the input\n      mutationInput = deleteInput;\n    } else {\n      // Otherwise, we construct the mutation input with the following logic\n      mutationInput = {};\n      var modelFields = Object.values(modelDefinition.fields);\n      try {\n        for (var modelFields_1 = __values(modelFields), modelFields_1_1 = modelFields_1.next(); !modelFields_1_1.done; modelFields_1_1 = modelFields_1.next()) {\n          var _f = modelFields_1_1.value,\n            name_1 = _f.name,\n            type = _f.type,\n            association = _f.association;\n          // model fields should be stripped out from the input\n          if (isModelFieldType(type)) {\n            // except for belongs to relations - we need to replace them with the correct foreign key(s)\n            if (isTargetNameAssociation(association) && association.connectionType === 'BELONGS_TO') {\n              var targetNames = extractTargetNamesFromSrc(association);\n              if (targetNames) {\n                try {\n                  // instead of including the connected model itself, we add its key(s) to the mutation input\n                  for (var targetNames_1 = (e_3 = void 0, __values(targetNames)), targetNames_1_1 = targetNames_1.next(); !targetNames_1_1.done; targetNames_1_1 = targetNames_1.next()) {\n                    var targetName = targetNames_1_1.value;\n                    mutationInput[targetName] = parsedData[targetName];\n                  }\n                } catch (e_3_1) {\n                  e_3 = {\n                    error: e_3_1\n                  };\n                } finally {\n                  try {\n                    if (targetNames_1_1 && !targetNames_1_1.done && (_c = targetNames_1.return)) _c.call(targetNames_1);\n                  } finally {\n                    if (e_3) throw e_3.error;\n                  }\n                }\n              }\n            }\n            continue;\n          }\n          // scalar fields / non-model types\n          if (operation === TransformerMutationType.UPDATE) {\n            if (!parsedData.hasOwnProperty(name_1)) {\n              // for update mutations - strip out a field if it's unchanged\n              continue;\n            }\n          }\n          // all other fields are added to the input object\n          mutationInput[name_1] = parsedData[name_1];\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (modelFields_1_1 && !modelFields_1_1.done && (_b = modelFields_1.return)) _b.call(modelFields_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n    // Build mutation variables input object\n    var input = __assign(__assign({}, mutationInput), {\n      _version: _version\n    });\n    var graphQLCondition = JSON.parse(condition);\n    var variables = __assign({\n      input: input\n    }, operation === TransformerMutationType.CREATE ? {} : {\n      condition: Object.keys(graphQLCondition).length > 0 ? graphQLCondition : null\n    });\n    return [query, variables, graphQLCondition, opName, modelDefinition];\n  };\n  MutationProcessor.prototype.opTypeFromTransformerOperation = function (operation) {\n    switch (operation) {\n      case TransformerMutationType.CREATE:\n        return OpType.INSERT;\n      case TransformerMutationType.DELETE:\n        return OpType.DELETE;\n      case TransformerMutationType.UPDATE:\n        return OpType.UPDATE;\n      case TransformerMutationType.GET:\n        // Intentionally blank\n        break;\n      default:\n        throw new Error(\"Invalid operation \" + operation);\n    }\n    // because it makes TS happy ...\n    return undefined;\n  };\n  MutationProcessor.prototype.pause = function () {\n    this.processing = false;\n  };\n  return MutationProcessor;\n}();\nvar MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nvar originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nexport var safeJitteredBackoff = function (attempt, _args, error) {\n  var attemptResult = originalJitteredBackoff(attempt);\n  // If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n  if (attemptResult === false && (error === null || error === void 0 ? void 0 : error.message) === 'Network Error') {\n    return MAX_RETRY_DELAY_MS;\n  }\n  return attemptResult;\n};\nexport { MutationProcessor };","map":{"version":3,"mappings":"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","names":["API","ConsoleLogger","Logger","jitteredBackoff","NonRetryableError","retry","BackgroundProcessManager","Observable","DISCARD","isModelFieldType","isTargetNameAssociation","OpType","ProcessName","extractTargetNamesFromSrc","USER","USER_AGENT_SUFFIX_DATASTORE","ID","buildGraphQLOperation","createMutationInstanceFromModelOperation","getModelAuthModes","TransformerMutationType","getTokenForCustomAuth","getMutationErrorType","MAX_ATTEMPTS","logger","schema","storage","userClasses","outbox","modelInstanceCreator","MutationEvent","amplifyConfig","authModeStrategy","errorHandler","conflictHandler","amplifyContext","WeakMap","generateQueries","MutationProcessor","Object","values","namespaces","forEach","namespace","models","filter","_a","syncable","createMutation","updateMutation","deleteMutation","_this","typeQuery","set","model","observer","undefined","runningProcesses","observable","resume","error","addCleaner","pause","close","open","isOpen","add","onTerminate","processing","isReady","namespaceName","head","operation","data","condition","modelConstructor","this_1","result","opName","modelDefinition","defaultAuthMode","aws_appsync_authenticationType","modelName","modelAuthModes","_b","operationAuthModes_1","toUpperCase","authModeAttempts_1","authModeRetry_1","debug","jitteredRetry","response","length","error_2","error_1","message","runExclusive","dequeue","record","hasMore","peek","next","mutationEvent","authMode","createQueryVariables","query","variables","graphQLCondition","authToken","_h","tryWith","userAgentSuffix","attempt","opType","opTypeFromTransformerOperation","graphql","err_1","errors","_c","_d","code","errorType","Error","retryWith","localModel","input","remoteModel","attempts","warn","err_2","_e","_f","opName_1","query_1","authToken_1","id","serverData","updatedMutation","relationships","save","recoverySuggestion","errorInfo","process","mutate","cause","err","_g","safeJitteredBackoff","queriesTuples","get","_version","parsedData","deleteInput","primaryKey","pkField","mutationInput","DELETE","modelFields","fields","name_1","type","association","connectionType","targetNames","targetName","UPDATE","hasOwnProperty","JSON","parse","CREATE","keys","INSERT","GET","MAX_RETRY_DELAY_MS","originalJitteredBackoff","_args","attemptResult"],"sources":["/frontend-react-js/node_modules/@aws-amplify/datastore/src/sync/processors/mutation.ts"],"sourcesContent":["import { API, GraphQLResult, GRAPHQL_AUTH_MODE } from '@aws-amplify/api';\nimport {\n\tConsoleLogger as Logger,\n\tjitteredBackoff,\n\tNonRetryableError,\n\tretry,\n\tBackgroundProcessManager,\n} from '@aws-amplify/core';\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport { MutationEvent } from '../';\nimport { ModelInstanceCreator } from '../../datastore/datastore';\nimport { ExclusiveStorage as Storage } from '../../storage/storage';\nimport {\n\tAuthModeStrategy,\n\tConflictHandler,\n\tDISCARD,\n\tErrorHandler,\n\tGraphQLCondition,\n\tInternalSchema,\n\tisModelFieldType,\n\tisTargetNameAssociation,\n\tModelInstanceMetadata,\n\tOpType,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tSchemaModel,\n\tTypeConstructorMap,\n\tProcessName,\n\tAmplifyContext,\n} from '../../types';\nimport {\n\textractTargetNamesFromSrc,\n\tUSER,\n\tUSER_AGENT_SUFFIX_DATASTORE,\n\tID,\n} from '../../util';\nimport { MutationEventOutbox } from '../outbox';\nimport {\n\tbuildGraphQLOperation,\n\tcreateMutationInstanceFromModelOperation,\n\tgetModelAuthModes,\n\tTransformerMutationType,\n\tgetTokenForCustomAuth,\n} from '../utils';\nimport { getMutationErrorType } from './errorMaps';\n\nconst MAX_ATTEMPTS = 10;\n\nconst logger = new Logger('DataStore');\n\ntype MutationProcessorEvent = {\n\toperation: TransformerMutationType;\n\tmodelDefinition: SchemaModel;\n\tmodel: PersistentModel;\n\thasMore: boolean;\n};\n\nclass MutationProcessor {\n\tprivate observer!: ZenObservable.Observer<MutationProcessorEvent>;\n\tprivate readonly typeQuery = new WeakMap<\n\t\tSchemaModel,\n\t\t[TransformerMutationType, string, string][]\n\t>();\n\tprivate processing: boolean = false;\n\n\tprivate runningProcesses = new BackgroundProcessManager();\n\n\tconstructor(\n\t\tprivate readonly schema: InternalSchema,\n\t\tprivate readonly storage: Storage,\n\t\tprivate readonly userClasses: TypeConstructorMap,\n\t\tprivate readonly outbox: MutationEventOutbox,\n\t\tprivate readonly modelInstanceCreator: ModelInstanceCreator,\n\t\tprivate readonly MutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\tprivate readonly amplifyConfig: Record<string, any> = {},\n\t\tprivate readonly authModeStrategy: AuthModeStrategy,\n\t\tprivate readonly errorHandler: ErrorHandler,\n\t\tprivate readonly conflictHandler: ConflictHandler,\n\t\tprivate readonly amplifyContext: AmplifyContext\n\t) {\n\t\tthis.amplifyContext.API = this.amplifyContext.API || API;\n\t\tthis.generateQueries();\n\t}\n\n\tprivate generateQueries() {\n\t\tObject.values(this.schema.namespaces).forEach(namespace => {\n\t\t\tObject.values(namespace.models)\n\t\t\t\t.filter(({ syncable }) => syncable)\n\t\t\t\t.forEach(model => {\n\t\t\t\t\tconst [createMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'CREATE'\n\t\t\t\t\t);\n\t\t\t\t\tconst [updateMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'UPDATE'\n\t\t\t\t\t);\n\t\t\t\t\tconst [deleteMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'DELETE'\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.typeQuery.set(model, [\n\t\t\t\t\t\tcreateMutation,\n\t\t\t\t\t\tupdateMutation,\n\t\t\t\t\t\tdeleteMutation,\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t});\n\t}\n\n\tprivate isReady() {\n\t\treturn this.observer !== undefined;\n\t}\n\n\tpublic start(): Observable<MutationProcessorEvent> {\n\t\tthis.runningProcesses = new BackgroundProcessManager();\n\n\t\tconst observable = new Observable<MutationProcessorEvent>(observer => {\n\t\t\tthis.observer = observer;\n\n\t\t\ttry {\n\t\t\t\tthis.resume();\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('mutations processor start error', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\treturn this.runningProcesses.addCleaner(async () => {\n\t\t\t\tthis.pause();\n\t\t\t});\n\t\t});\n\n\t\treturn observable;\n\t}\n\n\tpublic async stop() {\n\t\tawait this.runningProcesses.close();\n\t\tawait this.runningProcesses.open();\n\t}\n\n\tpublic async resume(): Promise<void> {\n\t\tawait (this.runningProcesses.isOpen &&\n\t\t\tthis.runningProcesses.add(async onTerminate => {\n\t\t\t\tif (\n\t\t\t\t\tthis.processing ||\n\t\t\t\t\t!this.isReady() ||\n\t\t\t\t\t!this.runningProcesses.isOpen\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.processing = true;\n\t\t\t\tlet head: MutationEvent;\n\t\t\t\tconst namespaceName = USER;\n\n\t\t\t\t// start to drain outbox\n\t\t\t\twhile (\n\t\t\t\t\tthis.processing &&\n\t\t\t\t\tthis.runningProcesses.isOpen &&\n\t\t\t\t\t(head = await this.outbox.peek(this.storage)) !== undefined\n\t\t\t\t) {\n\t\t\t\t\tconst { model, operation, data, condition } = head;\n\t\t\t\t\tconst modelConstructor = this.userClasses[\n\t\t\t\t\t\tmodel\n\t\t\t\t\t] as PersistentModelConstructor<MutationEvent>;\n\t\t\t\t\tlet result: GraphQLResult<Record<string, PersistentModel>> =\n\t\t\t\t\t\tundefined!;\n\t\t\t\t\tlet opName: string = undefined!;\n\t\t\t\t\tlet modelDefinition: SchemaModel = undefined!;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst modelAuthModes = await getModelAuthModes({\n\t\t\t\t\t\t\tauthModeStrategy: this.authModeStrategy,\n\t\t\t\t\t\t\tdefaultAuthMode:\n\t\t\t\t\t\t\t\tthis.amplifyConfig.aws_appsync_authenticationType,\n\t\t\t\t\t\t\tmodelName: model,\n\t\t\t\t\t\t\tschema: this.schema,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst operationAuthModes = modelAuthModes[operation.toUpperCase()];\n\n\t\t\t\t\t\tlet authModeAttempts = 0;\n\t\t\t\t\t\tconst authModeRetry = async () => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Attempting mutation with authMode: ${operationAuthModes[authModeAttempts]}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst response = await this.jitteredRetry(\n\t\t\t\t\t\t\t\t\tnamespaceName,\n\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t\toperation,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t\tcondition,\n\t\t\t\t\t\t\t\t\tmodelConstructor as any,\n\t\t\t\t\t\t\t\t\tthis.MutationEvent,\n\t\t\t\t\t\t\t\t\thead,\n\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts],\n\t\t\t\t\t\t\t\t\tonTerminate\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Mutation sent successfully with authMode: ${operationAuthModes[authModeAttempts]}`\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\treturn response;\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tauthModeAttempts++;\n\t\t\t\t\t\t\t\tif (authModeAttempts >= operationAuthModes.length) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t\t`Mutation failed with authMode: ${\n\t\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts - 1]\n\t\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Mutation failed with authMode: ${\n\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts - 1]\n\t\t\t\t\t\t\t\t\t}. Retrying with authMode: ${\n\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts]\n\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn await authModeRetry();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t[result, opName, modelDefinition] = await authModeRetry();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terror.message === 'Offline' ||\n\t\t\t\t\t\t\terror.message === 'RetryMutation'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tlogger.debug('done retrying');\n\t\t\t\t\t\tawait this.storage.runExclusive(async storage => {\n\t\t\t\t\t\t\tawait this.outbox.dequeue(storage);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst record = result.data![opName!];\n\t\t\t\t\tlet hasMore = false;\n\n\t\t\t\t\tawait this.storage.runExclusive(async storage => {\n\t\t\t\t\t\t// using runExclusive to prevent possible race condition\n\t\t\t\t\t\t// when another record gets enqueued between dequeue and peek\n\t\t\t\t\t\tawait this.outbox.dequeue(storage, record, operation);\n\t\t\t\t\t\thasMore = (await this.outbox.peek(storage)) !== undefined;\n\t\t\t\t\t});\n\n\t\t\t\t\tthis.observer.next!({\n\t\t\t\t\t\toperation,\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\tmodel: record,\n\t\t\t\t\t\thasMore,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// pauses itself\n\t\t\t\tthis.pause();\n\t\t\t}, 'mutation resume loop'));\n\t}\n\n\tprivate async jitteredRetry(\n\t\tnamespaceName: string,\n\t\tmodel: string,\n\t\toperation: TransformerMutationType,\n\t\tdata: string,\n\t\tcondition: string,\n\t\tmodelConstructor: PersistentModelConstructor<PersistentModel>,\n\t\tMutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\tmutationEvent: MutationEvent,\n\t\tauthMode: GRAPHQL_AUTH_MODE,\n\t\tonTerminate: Promise<void>\n\t): Promise<\n\t\t[GraphQLResult<Record<string, PersistentModel>>, string, SchemaModel]\n\t> {\n\t\treturn await retry(\n\t\t\tasync (\n\t\t\t\tmodel: string,\n\t\t\t\toperation: TransformerMutationType,\n\t\t\t\tdata: string,\n\t\t\t\tcondition: string,\n\t\t\t\tmodelConstructor: PersistentModelConstructor<PersistentModel>,\n\t\t\t\tMutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\t\t\tmutationEvent: MutationEvent\n\t\t\t) => {\n\t\t\t\tconst [query, variables, graphQLCondition, opName, modelDefinition] =\n\t\t\t\t\tthis.createQueryVariables(\n\t\t\t\t\t\tnamespaceName,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\toperation,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tcondition\n\t\t\t\t\t);\n\n\t\t\t\tconst authToken = await getTokenForCustomAuth(\n\t\t\t\t\tauthMode,\n\t\t\t\t\tthis.amplifyConfig\n\t\t\t\t);\n\n\t\t\t\tconst tryWith = {\n\t\t\t\t\tquery,\n\t\t\t\t\tvariables,\n\t\t\t\t\tauthMode,\n\t\t\t\t\tauthToken,\n\t\t\t\t\tuserAgentSuffix: USER_AGENT_SUFFIX_DATASTORE,\n\t\t\t\t};\n\t\t\t\tlet attempt = 0;\n\n\t\t\t\tconst opType = this.opTypeFromTransformerOperation(operation);\n\n\t\t\t\tdo {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = <GraphQLResult<Record<string, PersistentModel>>>(\n\t\t\t\t\t\t\tawait this.amplifyContext.API.graphql(tryWith)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Use `as any` because TypeScript doesn't seem to like passing tuples\n\t\t\t\t\t\t// through generic params.\n\t\t\t\t\t\treturn [result, opName, modelDefinition] as any;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tif (err.errors && err.errors.length > 0) {\n\t\t\t\t\t\t\tconst [error] = err.errors;\n\t\t\t\t\t\t\tconst { originalError: { code = null } = {} } = error;\n\n\t\t\t\t\t\t\tif (error.errorType === 'Unauthorized') {\n\t\t\t\t\t\t\t\tthrow new NonRetryableError('Unauthorized');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\terror.message === 'Network Error' ||\n\t\t\t\t\t\t\t\tcode === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tif (!this.processing) {\n\t\t\t\t\t\t\t\t\tthrow new NonRetryableError('Offline');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// TODO: Check errors on different env (react-native or other browsers)\n\t\t\t\t\t\t\t\tthrow new Error('Network Error');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (error.errorType === 'ConflictUnhandled') {\n\t\t\t\t\t\t\t\t// TODO: add on ConflictConditionalCheck error query last from server\n\t\t\t\t\t\t\t\tattempt++;\n\t\t\t\t\t\t\t\tlet retryWith: PersistentModel | typeof DISCARD;\n\n\t\t\t\t\t\t\t\tif (attempt > MAX_ATTEMPTS) {\n\t\t\t\t\t\t\t\t\tretryWith = DISCARD;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tretryWith = await this.conflictHandler!({\n\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\tlocalModel: this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\tvariables.input\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\tremoteModel: this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\terror.data\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\toperation: opType,\n\t\t\t\t\t\t\t\t\t\t\tattempts: attempt,\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\tlogger.warn('conflict trycatch', err);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (retryWith === DISCARD) {\n\t\t\t\t\t\t\t\t\t// Query latest from server and notify merger\n\n\t\t\t\t\t\t\t\t\tconst [[, opName, query]] = buildGraphQLOperation(\n\t\t\t\t\t\t\t\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\t'GET'\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst authToken = await getTokenForCustomAuth(\n\t\t\t\t\t\t\t\t\t\tauthMode,\n\t\t\t\t\t\t\t\t\t\tthis.amplifyConfig\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst serverData = <\n\t\t\t\t\t\t\t\t\t\tGraphQLResult<Record<string, PersistentModel>>\n\t\t\t\t\t\t\t\t\t>await this.amplifyContext.API.graphql({\n\t\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\t\tvariables: { id: variables.input.id },\n\t\t\t\t\t\t\t\t\t\tauthMode,\n\t\t\t\t\t\t\t\t\t\tauthToken,\n\t\t\t\t\t\t\t\t\t\tuserAgentSuffix: USER_AGENT_SUFFIX_DATASTORE,\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t// onTerminate cancel graphql()\n\n\t\t\t\t\t\t\t\t\treturn [serverData, opName, modelDefinition];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst namespace = this.schema.namespaces[namespaceName];\n\n\t\t\t\t\t\t\t\t// convert retry with to tryWith\n\t\t\t\t\t\t\t\tconst updatedMutation =\n\t\t\t\t\t\t\t\t\tcreateMutationInstanceFromModelOperation(\n\t\t\t\t\t\t\t\t\t\tnamespace.relationships!,\n\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\topType,\n\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\tretryWith,\n\t\t\t\t\t\t\t\t\t\tgraphQLCondition,\n\t\t\t\t\t\t\t\t\t\tMutationEvent,\n\t\t\t\t\t\t\t\t\t\tthis.modelInstanceCreator,\n\t\t\t\t\t\t\t\t\t\tmutationEvent.id\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tawait this.storage.save(updatedMutation);\n\n\t\t\t\t\t\t\t\tthrow new NonRetryableError('RetryMutation');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tthis.errorHandler({\n\t\t\t\t\t\t\t\t\t\trecoverySuggestion:\n\t\t\t\t\t\t\t\t\t\t\t'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n\t\t\t\t\t\t\t\t\t\tlocalModel: variables.input,\n\t\t\t\t\t\t\t\t\t\tmessage: error.message,\n\t\t\t\t\t\t\t\t\t\toperation,\n\t\t\t\t\t\t\t\t\t\terrorType: getMutationErrorType(error),\n\t\t\t\t\t\t\t\t\t\terrorInfo: error.errorInfo,\n\t\t\t\t\t\t\t\t\t\tprocess: ProcessName.mutate,\n\t\t\t\t\t\t\t\t\t\tcause: error,\n\t\t\t\t\t\t\t\t\t\tremoteModel: error.data\n\t\t\t\t\t\t\t\t\t\t\t? this.modelInstanceCreator(modelConstructor, error.data)\n\t\t\t\t\t\t\t\t\t\t\t: null!,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tlogger.warn('Mutation error handler failed with:', err);\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// Return empty tuple, dequeues the mutation\n\t\t\t\t\t\t\t\t\treturn error.data\n\t\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t\t{ data: { [opName]: error.data } },\n\t\t\t\t\t\t\t\t\t\t\t\topName,\n\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\t  ]\n\t\t\t\t\t\t\t\t\t\t: [];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n\t\t\t\t\t\t\t// These errors should not be retried.\n\t\t\t\t\t\t\tthrow new NonRetryableError(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (tryWith);\n\t\t\t},\n\t\t\t[\n\t\t\t\tmodel,\n\t\t\t\toperation,\n\t\t\t\tdata,\n\t\t\t\tcondition,\n\t\t\t\tmodelConstructor,\n\t\t\t\tMutationEvent,\n\t\t\t\tmutationEvent,\n\t\t\t],\n\t\t\tsafeJitteredBackoff,\n\t\t\tonTerminate\n\t\t);\n\t}\n\n\tprivate createQueryVariables(\n\t\tnamespaceName: string,\n\t\tmodel: string,\n\t\toperation: TransformerMutationType,\n\t\tdata: string,\n\t\tcondition: string\n\t): [string, Record<string, any>, GraphQLCondition, string, SchemaModel] {\n\t\tconst modelDefinition = this.schema.namespaces[namespaceName].models[model];\n\t\tconst { primaryKey } = this.schema.namespaces[namespaceName].keys![model];\n\n\t\tconst queriesTuples = this.typeQuery.get(modelDefinition);\n\n\t\tconst [, opName, query] = queriesTuples!.find(\n\t\t\t([transformerMutationType]) => transformerMutationType === operation\n\t\t)!;\n\n\t\tconst { _version, ...parsedData } = <ModelInstanceMetadata>JSON.parse(data);\n\n\t\t// include all the fields that comprise a custom PK if one is specified\n\t\tconst deleteInput = {};\n\t\tif (primaryKey?.length) {\n\t\t\tfor (const pkField of primaryKey) {\n\t\t\t\tdeleteInput[pkField] = parsedData[pkField];\n\t\t\t}\n\t\t} else {\n\t\t\tdeleteInput[ID] = (<any>parsedData).id;\n\t\t}\n\n\t\tlet mutationInput;\n\n\t\tif (operation === TransformerMutationType.DELETE) {\n\t\t\t// For DELETE mutations, only the key(s) are included in the input\n\t\t\tmutationInput = <ModelInstanceMetadata>deleteInput;\n\t\t} else {\n\t\t\t// Otherwise, we construct the mutation input with the following logic\n\t\t\tmutationInput = {};\n\t\t\tconst modelFields = Object.values(modelDefinition.fields);\n\n\t\t\tfor (const { name, type, association } of modelFields) {\n\t\t\t\t// model fields should be stripped out from the input\n\t\t\t\tif (isModelFieldType(type)) {\n\t\t\t\t\t// except for belongs to relations - we need to replace them with the correct foreign key(s)\n\t\t\t\t\tif (\n\t\t\t\t\t\tisTargetNameAssociation(association) &&\n\t\t\t\t\t\tassociation.connectionType === 'BELONGS_TO'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst targetNames: string[] | undefined =\n\t\t\t\t\t\t\textractTargetNamesFromSrc(association);\n\n\t\t\t\t\t\tif (targetNames) {\n\t\t\t\t\t\t\t// instead of including the connected model itself, we add its key(s) to the mutation input\n\t\t\t\t\t\t\tfor (const targetName of targetNames) {\n\t\t\t\t\t\t\t\tmutationInput[targetName] = parsedData[targetName];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// scalar fields / non-model types\n\n\t\t\t\tif (operation === TransformerMutationType.UPDATE) {\n\t\t\t\t\tif (!parsedData.hasOwnProperty(name)) {\n\t\t\t\t\t\t// for update mutations - strip out a field if it's unchanged\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// all other fields are added to the input object\n\t\t\t\tmutationInput[name] = parsedData[name];\n\t\t\t}\n\t\t}\n\n\t\t// Build mutation variables input object\n\t\tconst input: ModelInstanceMetadata = {\n\t\t\t...mutationInput,\n\t\t\t_version,\n\t\t};\n\n\t\tconst graphQLCondition = <GraphQLCondition>JSON.parse(condition);\n\n\t\tconst variables = {\n\t\t\tinput,\n\t\t\t...(operation === TransformerMutationType.CREATE\n\t\t\t\t? {}\n\t\t\t\t: {\n\t\t\t\t\t\tcondition:\n\t\t\t\t\t\t\tObject.keys(graphQLCondition).length > 0\n\t\t\t\t\t\t\t\t? graphQLCondition\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t  }),\n\t\t};\n\t\treturn [query, variables, graphQLCondition, opName, modelDefinition];\n\t}\n\n\tprivate opTypeFromTransformerOperation(\n\t\toperation: TransformerMutationType\n\t): OpType {\n\t\tswitch (operation) {\n\t\t\tcase TransformerMutationType.CREATE:\n\t\t\t\treturn OpType.INSERT;\n\t\t\tcase TransformerMutationType.DELETE:\n\t\t\t\treturn OpType.DELETE;\n\t\t\tcase TransformerMutationType.UPDATE:\n\t\t\t\treturn OpType.UPDATE;\n\t\t\tcase TransformerMutationType.GET: // Intentionally blank\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid operation ${operation}`);\n\t\t}\n\n\t\t// because it makes TS happy ...\n\t\treturn undefined!;\n\t}\n\n\tpublic pause() {\n\t\tthis.processing = false;\n\t}\n}\n\nconst MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nconst originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nexport const safeJitteredBackoff: typeof originalJitteredBackoff = (\n\tattempt,\n\t_args,\n\terror\n) => {\n\tconst attemptResult = originalJitteredBackoff(attempt);\n\n\t// If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n\tif (attemptResult === false && error?.message === 'Network Error') {\n\t\treturn MAX_RETRY_DELAY_MS;\n\t}\n\n\treturn attemptResult;\n};\n\nexport { MutationProcessor };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}