{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { ClientDevice, Credentials, getAmplifyUserAgent, StorageHelper, transferKeyToUpperCase } from '@aws-amplify/core';\nimport { Cache } from '@aws-amplify/cache';\nimport { ChannelType, GetInAppMessagesCommand, UpdateEndpointCommand, PinpointClient } from '@aws-sdk/client-pinpoint';\nimport { v4 as uuid } from 'uuid';\nimport { addMessageInteractionEventListener } from '../../eventListeners';\nimport SessionTracker from '../../SessionTracker';\nimport { InAppMessageInteractionEvent } from '../../types';\nimport { AWSPinpointMessageEvent } from './types';\nimport { clearMemo, dispatchInAppMessagingEvent, extractContent, extractMetadata, getStartOfDay, interpretLayout, isBeforeEndDate, logger, matchesAttributes, matchesEventType, matchesMetrics, recordAnalyticsEvent } from './utils';\nvar MESSAGE_DAILY_COUNT_KEY = 'pinpointProvider_inAppMessages_dailyCount';\nvar MESSAGE_TOTAL_COUNT_KEY = 'pinpointProvider_inAppMessages_totalCount';\nvar AWSPinpointProvider = /** @class */function () {\n  function AWSPinpointProvider() {\n    var _this = this;\n    var _a;\n    this.config = {};\n    this.configured = false;\n    this.endpointInitialized = false;\n    this.initialized = false;\n    this.configure = function (config) {\n      if (config === void 0) {\n        config = {};\n      }\n      _this.config = __assign(__assign({}, _this.config), config);\n      logger.debug('configure AWSPinpointProvider', _this.config);\n      // some configuration steps should not be re-run even if provider is re-configured for some reason\n      if (!_this.configured) {\n        _this.sessionTracker = new SessionTracker(_this.sessionStateChangeHandler);\n        _this.sessionTracker.start();\n        // wire up default Pinpoint message event handling\n        addMessageInteractionEventListener(function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_DISPLAYED);\n        }, InAppMessageInteractionEvent.MESSAGE_DISPLAYED);\n        addMessageInteractionEventListener(function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_DISMISSED);\n        }, InAppMessageInteractionEvent.MESSAGE_DISMISSED);\n        addMessageInteractionEventListener(function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_ACTION_TAKEN);\n        }, InAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN);\n      }\n      _this.configured = true;\n      dispatchInAppMessagingEvent('pinpointProvider_configured', null);\n      return _this.config;\n    };\n    this.getInAppMessages = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, appId, endpointId, pinpointClient, input, command, response, messages, err_1;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!!this.initialized) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.init()];\n            case 1:\n              _b.sent();\n              _b.label = 2;\n            case 2:\n              // There is no way to granuarly reconcile the filter memoization as the keys are composited from a message id and\n              // event properties thus opting to just clear them out when getting messages rather than leave potentially\n              // obsolete entries that will no longer serve any purpose.\n              clearMemo();\n              _b.label = 3;\n            case 3:\n              _b.trys.push([3, 6,, 7]);\n              return [4 /*yield*/, this.updateEndpoint()];\n            case 4:\n              _b.sent();\n              _a = this.config, appId = _a.appId, endpointId = _a.endpointId, pinpointClient = _a.pinpointClient;\n              input = {\n                ApplicationId: appId,\n                EndpointId: endpointId\n              };\n              command = new GetInAppMessagesCommand(input);\n              logger.debug('getting in-app messages', input);\n              return [4 /*yield*/, pinpointClient.send(command)];\n            case 5:\n              response = _b.sent();\n              messages = response.InAppMessagesResponse.InAppMessageCampaigns;\n              dispatchInAppMessagingEvent('getInAppMessages', messages);\n              return [2 /*return*/, messages];\n            case 6:\n              err_1 = _b.sent();\n              logger.error('Error getting in-app messages', err_1);\n              throw err_1;\n            case 7:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.processInAppMessages = function (messages, event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var highestPrioritySeen;\n        var _this = this;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this.initialized) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.init()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              return [2 /*return*/, this.normalizeMessages(messages.reduce(function (acc, message) {\n                var messageQualifies = matchesEventType(message, event) && matchesAttributes(message, event) && matchesMetrics(message, event) && isBeforeEndDate(message) && _this.isBelowCap(message);\n                // filter all qualifying messages returning only those that are of (relative) highest priority\n                if (messageQualifies) {\n                  // have not yet encountered message with priority\n                  if (!highestPrioritySeen) {\n                    // this message has priority, so reset the accumulator with this message only\n                    if (message.Priority) {\n                      highestPrioritySeen = message.Priority;\n                      return [message];\n                    } else {\n                      // this message also has no priority, so just add this message to accumulator\n                      acc.push(message);\n                    }\n                    // have previously encountered message with priority, so only messages with priority matter now\n                  } else if (message.Priority) {\n                    // this message has higher priority (lower number), so reset the accumulator with this message only\n                    if (message.Priority < highestPrioritySeen) {\n                      highestPrioritySeen = message.Priority;\n                      return [message];\n                      // this message has the same priority, so just add this message to accumulator\n                    } else if (message.Priority === highestPrioritySeen) {\n                      acc.push(message);\n                    }\n                  }\n                }\n                return acc;\n              }, []))];\n          }\n        });\n      });\n    };\n    this.identifyUser = function (userId, userInfo) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var err_2;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this.initialized) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.init()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              _a.trys.push([2, 4,, 5]);\n              return [4 /*yield*/, this.updateEndpoint(userId, userInfo)];\n            case 3:\n              _a.sent();\n              return [3 /*break*/, 5];\n            case 4:\n              err_2 = _a.sent();\n              logger.error('Error identifying user', err_2);\n              throw err_2;\n            case 5:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.init = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, endpointId, storage, providerName, _b, err_3;\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              _a = this.config, endpointId = _a.endpointId, storage = _a.storage;\n              providerName = this.getProviderName();\n              _c.label = 1;\n            case 1:\n              _c.trys.push([1, 6,, 7]);\n              if (!(typeof storage.sync === 'function')) return [3 /*break*/, 3];\n              return [4 /*yield*/, storage.sync()];\n            case 2:\n              _c.sent();\n              _c.label = 3;\n            case 3:\n              if (!!endpointId) return [3 /*break*/, 5];\n              _b = this.config;\n              return [4 /*yield*/, this.getEndpointId()];\n            case 4:\n              _b.endpointId = _c.sent();\n              _c.label = 5;\n            case 5:\n              this.initialized = true;\n              return [3 /*break*/, 7];\n            case 6:\n              err_3 = _c.sent();\n              logger.error(\"Failed to initialize \" + providerName, err_3);\n              return [3 /*break*/, 7];\n            case 7:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.initPinpointClient = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, appId, credentials, pinpointClient, region;\n        return __generator(this, function (_b) {\n          _a = this.config, appId = _a.appId, credentials = _a.credentials, pinpointClient = _a.pinpointClient, region = _a.region;\n          if (!appId || !credentials || !region) {\n            throw new Error('One or more of credentials, appId or region is not configured');\n          }\n          if (pinpointClient) {\n            pinpointClient.destroy();\n          }\n          this.config.pinpointClient = new PinpointClient({\n            region: region,\n            credentials: credentials,\n            customUserAgent: getAmplifyUserAgent()\n          });\n          return [2 /*return*/];\n        });\n      });\n    };\n\n    this.getEndpointId = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var appId, cacheKey, cachedEndpointId, endpointId, ttl, expiration;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              appId = this.config.appId;\n              cacheKey = this.getSubCategory() + \":\" + this.getProviderName() + \":\" + appId;\n              return [4 /*yield*/, Cache.getItem(cacheKey)];\n            case 1:\n              cachedEndpointId = _a.sent();\n              // Found in cache, just return it\n              if (cachedEndpointId) {\n                return [2 /*return*/, cachedEndpointId];\n              }\n              endpointId = uuid();\n              ttl = 1000 * 60 * 60 * 24 * 365 * 100;\n              expiration = new Date().getTime() + ttl;\n              Cache.setItem(cacheKey, endpointId, {\n                expires: expiration,\n                priority: 1\n              });\n              return [2 /*return*/, endpointId];\n          }\n        });\n      });\n    };\n    this.updateEndpoint = function (userId, userInfo) {\n      if (userId === void 0) {\n        userId = null;\n      }\n      if (userInfo === void 0) {\n        userInfo = null;\n      }\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, appId, credentials, endpointId, _b, endpointInfo, pinpointClient, currentCredentials, credentialsUpdated, _c, address, attributes, demographic, location_1, metrics, optOut, _d, appVersion, make, model, platform, version, input, command, err_4;\n        var _e;\n        return __generator(this, function (_f) {\n          switch (_f.label) {\n            case 0:\n              _a = this.config, appId = _a.appId, credentials = _a.credentials, endpointId = _a.endpointId, _b = _a.endpointInfo, endpointInfo = _b === void 0 ? {} : _b, pinpointClient = _a.pinpointClient;\n              return [4 /*yield*/, this.getCredentials()];\n            case 1:\n              currentCredentials = _f.sent();\n              credentialsUpdated = !credentials || Object.keys(currentCredentials).some(function (key) {\n                return currentCredentials[key] !== credentials[key];\n              });\n              // If endpoint is already initialized, and nothing else is changing, just early return\n              if (this.endpointInitialized && !credentialsUpdated && !userId && !userInfo) {\n                return [2 /*return*/];\n              }\n              // Update credentials\n              this.config.credentials = currentCredentials;\n              _f.label = 2;\n            case 2:\n              _f.trys.push([2, 6,, 7]);\n              if (!(!pinpointClient || credentialsUpdated)) return [3 /*break*/, 4];\n              return [4 /*yield*/, this.initPinpointClient()];\n            case 3:\n              _f.sent();\n              _f.label = 4;\n            case 4:\n              _c = userInfo !== null && userInfo !== void 0 ? userInfo : {}, address = _c.address, attributes = _c.attributes, demographic = _c.demographic, location_1 = _c.location, metrics = _c.metrics, optOut = _c.optOut;\n              _d = this.clientInfo, appVersion = _d.appVersion, make = _d.make, model = _d.model, platform = _d.platform, version = _d.version;\n              input = {\n                ApplicationId: appId,\n                EndpointId: endpointId,\n                EndpointRequest: {\n                  RequestId: uuid(),\n                  EffectiveDate: new Date().toISOString(),\n                  ChannelType: ChannelType.IN_APP,\n                  Address: address !== null && address !== void 0 ? address : endpointInfo.address,\n                  Attributes: __assign(__assign({}, endpointInfo.attributes), attributes),\n                  Demographic: __assign({\n                    AppVersion: appVersion,\n                    Make: make,\n                    Model: model,\n                    ModelVersion: version,\n                    Platform: platform\n                  }, transferKeyToUpperCase(__assign(__assign({}, endpointInfo.demographic), demographic))),\n                  Location: transferKeyToUpperCase(__assign(__assign({}, endpointInfo.location), location_1)),\n                  Metrics: __assign(__assign({}, endpointInfo.metrics), metrics),\n                  OptOut: optOut !== null && optOut !== void 0 ? optOut : endpointInfo.optOut,\n                  User: {\n                    UserId: (_e = userId !== null && userId !== void 0 ? userId : endpointInfo.userId) !== null && _e !== void 0 ? _e : currentCredentials.identityId,\n                    UserAttributes: attributes !== null && attributes !== void 0 ? attributes : endpointInfo.userAttributes\n                  }\n                }\n              };\n              command = new UpdateEndpointCommand(input);\n              logger.debug('updating endpoint', input);\n              return [4 /*yield*/, this.config.pinpointClient.send(command)];\n            case 5:\n              _f.sent();\n              this.endpointInitialized = true;\n              return [3 /*break*/, 7];\n            case 6:\n              err_4 = _f.sent();\n              throw err_4;\n            case 7:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.getCredentials = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var credentials, err_5;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n              return [4 /*yield*/, Credentials.get()];\n            case 1:\n              credentials = _a.sent();\n              if (!credentials) {\n                logger.debug('no credentials found');\n                return [2 /*return*/, null];\n              }\n              return [2 /*return*/, Credentials.shear(credentials)];\n            case 2:\n              err_5 = _a.sent();\n              logger.error('Error getting credentials:', err_5);\n              return [2 /*return*/, null];\n            case 3:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.sessionStateChangeHandler = function (state) {\n      if (state === 'started') {\n        // reset all session counts\n        _this.sessionMessageCountMap = {};\n      }\n    };\n    this.isBelowCap = function (_a) {\n      var CampaignId = _a.CampaignId,\n        SessionCap = _a.SessionCap,\n        DailyCap = _a.DailyCap,\n        TotalCap = _a.TotalCap;\n      var _b = _this.getMessageCounts(CampaignId),\n        sessionCount = _b.sessionCount,\n        dailyCount = _b.dailyCount,\n        totalCount = _b.totalCount;\n      return (!SessionCap || sessionCount < SessionCap) && (!DailyCap || dailyCount < DailyCap) && (!TotalCap || totalCount < TotalCap);\n    };\n    // Use the current session count in memory or initialize as empty count\n    this.getSessionCount = function (messageId) {\n      return _this.sessionMessageCountMap[messageId] || 0;\n    };\n    this.getDailyCount = function () {\n      var storage = _this.config.storage;\n      var today = getStartOfDay();\n      var item = storage.getItem(MESSAGE_DAILY_COUNT_KEY);\n      // Parse stored count or initialize as empty count\n      var counter = item ? JSON.parse(item) : {\n        count: 0,\n        lastCountTimestamp: today\n      };\n      // If the stored counter timestamp is today, use it as the count, otherwise reset to 0\n      return counter.lastCountTimestamp === today ? counter.count : 0;\n    };\n    this.getTotalCountMap = function () {\n      var storage = _this.config.storage;\n      var item = storage.getItem(MESSAGE_TOTAL_COUNT_KEY);\n      // Parse stored count map or initialize as empty\n      return item ? JSON.parse(item) : {};\n    };\n    this.getTotalCount = function (messageId) {\n      var countMap = _this.getTotalCountMap();\n      // Return stored count or initialize as empty count\n      return countMap[messageId] || 0;\n    };\n    this.getMessageCounts = function (messageId) {\n      try {\n        return {\n          sessionCount: _this.getSessionCount(messageId),\n          dailyCount: _this.getDailyCount(),\n          totalCount: _this.getTotalCount(messageId)\n        };\n      } catch (err) {\n        logger.error('Failed to get message counts from storage', err);\n      }\n    };\n    this.setSessionCount = function (messageId, count) {\n      _this.sessionMessageCountMap[messageId] = count;\n    };\n    this.setDailyCount = function (count) {\n      var storage = _this.config.storage;\n      var dailyCount = {\n        count: count,\n        lastCountTimestamp: getStartOfDay()\n      };\n      try {\n        storage.setItem(MESSAGE_DAILY_COUNT_KEY, JSON.stringify(dailyCount));\n      } catch (err) {\n        logger.error('Failed to save daily message count to storage', err);\n      }\n    };\n    this.setTotalCountMap = function (countMap) {\n      var storage = _this.config.storage;\n      try {\n        storage.setItem(MESSAGE_TOTAL_COUNT_KEY, JSON.stringify(countMap));\n      } catch (err) {\n        logger.error('Failed to save total count to storage', err);\n      }\n    };\n    this.setTotalCount = function (messageId, count) {\n      var _a;\n      var updatedMap = __assign(__assign({}, _this.getTotalCountMap()), (_a = {}, _a[messageId] = count, _a));\n      _this.setTotalCountMap(updatedMap);\n    };\n    this.incrementCounts = function (messageId) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, sessionCount, dailyCount, totalCount;\n        return __generator(this, function (_b) {\n          _a = this.getMessageCounts(messageId), sessionCount = _a.sessionCount, dailyCount = _a.dailyCount, totalCount = _a.totalCount;\n          this.setSessionCount(messageId, sessionCount + 1);\n          this.setDailyCount(dailyCount + 1);\n          this.setTotalCount(messageId, totalCount + 1);\n          return [2 /*return*/];\n        });\n      });\n    };\n\n    this.normalizeMessages = function (messages) {\n      return messages.map(function (message) {\n        var CampaignId = message.CampaignId,\n          InAppMessage = message.InAppMessage;\n        return {\n          id: CampaignId,\n          content: extractContent(message),\n          layout: interpretLayout(InAppMessage.Layout),\n          metadata: extractMetadata(message)\n        };\n      });\n    };\n    this.recordMessageEvent = function (message, event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this.initialized) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.init()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              recordAnalyticsEvent(event, message);\n              if (!(event === AWSPinpointMessageEvent.MESSAGE_DISPLAYED)) return [3 /*break*/, 4];\n              return [4 /*yield*/, this.incrementCounts(message.id)];\n            case 3:\n              _a.sent();\n              _a.label = 4;\n            case 4:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.sessionMessageCountMap = {};\n    this.config = {\n      storage: new StorageHelper().getStorage()\n    };\n    this.clientInfo = (_a = ClientDevice.clientInfo()) !== null && _a !== void 0 ? _a : {};\n  }\n  /**\n   * get the category of the plugin\n   */\n  AWSPinpointProvider.prototype.getCategory = function () {\n    return AWSPinpointProvider.category;\n  };\n  /**\n   * get the sub-category of the plugin\n   */\n  AWSPinpointProvider.prototype.getSubCategory = function () {\n    return AWSPinpointProvider.subCategory;\n  };\n  /**\n   * get provider name of the plugin\n   */\n  AWSPinpointProvider.prototype.getProviderName = function () {\n    return AWSPinpointProvider.providerName;\n  };\n  AWSPinpointProvider.category = 'Notifications';\n  AWSPinpointProvider.subCategory = 'InAppMessaging';\n  AWSPinpointProvider.providerName = 'AWSPinpoint';\n  return AWSPinpointProvider;\n}();\nexport default AWSPinpointProvider;","map":{"version":3,"mappings":"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","names":["ClientDevice","Credentials","getAmplifyUserAgent","StorageHelper","transferKeyToUpperCase","Cache","ChannelType","GetInAppMessagesCommand","UpdateEndpointCommand","PinpointClient","v4","uuid","addMessageInteractionEventListener","SessionTracker","InAppMessageInteractionEvent","AWSPinpointMessageEvent","clearMemo","dispatchInAppMessagingEvent","extractContent","extractMetadata","getStartOfDay","interpretLayout","isBeforeEndDate","logger","matchesAttributes","matchesEventType","matchesMetrics","recordAnalyticsEvent","MESSAGE_DAILY_COUNT_KEY","MESSAGE_TOTAL_COUNT_KEY","config","_this","debug","configured","sessionTracker","sessionStateChangeHandler","start","message","recordMessageEvent","MESSAGE_DISPLAYED","MESSAGE_DISMISSED","MESSAGE_ACTION_TAKEN","initialized","init","_b","updateEndpoint","_a","appId","endpointId","pinpointClient","input","ApplicationId","EndpointId","command","send","response","messages","InAppMessagesResponse","error","err_1","event","normalizeMessages","reduce","acc","messageQualifies","isBelowCap","highestPrioritySeen","Priority","push","userId","userInfo","err_2","storage","providerName","getProviderName","sync","_c","getEndpointId","err_3","credentials","region","Error","destroy","customUserAgent","cacheKey","getSubCategory","getItem","cachedEndpointId","ttl","expiration","Date","getTime","setItem","expires","priority","endpointInfo","getCredentials","currentCredentials","_f","credentialsUpdated","Object","keys","some","key","endpointInitialized","initPinpointClient","address","attributes","demographic","location_1","metrics","optOut","_d","clientInfo","appVersion","make","model","platform","version","EndpointRequest","RequestId","EffectiveDate","toISOString","IN_APP","Address","Attributes","Demographic","AppVersion","Make","Model","ModelVersion","Platform","Location","location","Metrics","OptOut","User","UserId","identityId","UserAttributes","userAttributes","err_4","get","shear","err_5","state","sessionMessageCountMap","CampaignId","SessionCap","DailyCap","TotalCap","sessionCount","dailyCount","totalCount","messageId","today","item","counter","JSON","parse","count","lastCountTimestamp","countMap","getTotalCountMap","getSessionCount","getDailyCount","getTotalCount","err","stringify","updatedMap","setTotalCountMap","getMessageCounts","setSessionCount","setDailyCount","setTotalCount","map","InAppMessage","id","content","layout","Layout","metadata","incrementCounts","getStorage","AWSPinpointProvider","category","subCategory"],"sources":["/frontend-react-js/node_modules/@aws-amplify/notifications/src/InAppMessaging/Providers/AWSPinpointProvider/index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tClientDevice,\n\tCredentials,\n\tgetAmplifyUserAgent,\n\tStorageHelper,\n\ttransferKeyToUpperCase,\n} from '@aws-amplify/core';\nimport { Cache } from '@aws-amplify/cache';\nimport {\n\tChannelType,\n\tGetInAppMessagesCommand,\n\tGetInAppMessagesCommandInput,\n\tInAppMessageCampaign as PinpointInAppMessage,\n\tUpdateEndpointCommand,\n\tUpdateEndpointCommandInput,\n\tPinpointClient,\n} from '@aws-sdk/client-pinpoint';\nimport { v4 as uuid } from 'uuid';\n\nimport { addMessageInteractionEventListener } from '../../eventListeners';\nimport { NotificationsCategory } from '../../../types';\nimport SessionTracker, {\n\tSessionState,\n\tSessionStateChangeHandler,\n} from '../../SessionTracker';\nimport {\n\tInAppMessage,\n\tInAppMessageInteractionEvent,\n\tInAppMessageLayout,\n\tInAppMessagingEvent,\n\tInAppMessagingProvider,\n\tNotificationsSubcategory,\n\tUserInfo,\n} from '../../types';\nimport {\n\tAWSPinpointMessageEvent,\n\tAWSPinpointUserInfo,\n\tDailyInAppMessageCounter,\n\tInAppMessageCountMap,\n\tInAppMessageCounts,\n} from './types';\nimport {\n\tclearMemo,\n\tdispatchInAppMessagingEvent,\n\textractContent,\n\textractMetadata,\n\tgetStartOfDay,\n\tinterpretLayout,\n\tisBeforeEndDate,\n\tlogger,\n\tmatchesAttributes,\n\tmatchesEventType,\n\tmatchesMetrics,\n\trecordAnalyticsEvent,\n} from './utils';\n\nconst MESSAGE_DAILY_COUNT_KEY = 'pinpointProvider_inAppMessages_dailyCount';\nconst MESSAGE_TOTAL_COUNT_KEY = 'pinpointProvider_inAppMessages_totalCount';\n\nexport default class AWSPinpointProvider implements InAppMessagingProvider {\n\tstatic category: NotificationsCategory = 'Notifications';\n\tstatic subCategory: NotificationsSubcategory = 'InAppMessaging';\n\tstatic providerName = 'AWSPinpoint';\n\n\tprivate clientInfo;\n\tprivate config: Record<string, any> = {};\n\tprivate configured = false;\n\tprivate endpointInitialized = false;\n\tprivate initialized = false;\n\tprivate sessionMessageCountMap: InAppMessageCountMap;\n\tprivate sessionTracker: SessionTracker;\n\n\tconstructor() {\n\t\tthis.sessionMessageCountMap = {};\n\t\tthis.config = {\n\t\t\tstorage: new StorageHelper().getStorage(),\n\t\t};\n\t\tthis.clientInfo = ClientDevice.clientInfo() ?? {};\n\t}\n\n\t/**\n\t * get the category of the plugin\n\t */\n\tgetCategory() {\n\t\treturn AWSPinpointProvider.category;\n\t}\n\n\t/**\n\t * get the sub-category of the plugin\n\t */\n\tgetSubCategory() {\n\t\treturn AWSPinpointProvider.subCategory;\n\t}\n\n\t/**\n\t * get provider name of the plugin\n\t */\n\tgetProviderName(): string {\n\t\treturn AWSPinpointProvider.providerName;\n\t}\n\n\tconfigure = (config = {}): object => {\n\t\tthis.config = { ...this.config, ...config };\n\n\t\tlogger.debug('configure AWSPinpointProvider', this.config);\n\n\t\t// some configuration steps should not be re-run even if provider is re-configured for some reason\n\t\tif (!this.configured) {\n\t\t\tthis.sessionTracker = new SessionTracker(this.sessionStateChangeHandler);\n\t\t\tthis.sessionTracker.start();\n\t\t\t// wire up default Pinpoint message event handling\n\t\t\taddMessageInteractionEventListener((message: InAppMessage) => {\n\t\t\t\tthis.recordMessageEvent(\n\t\t\t\t\tmessage,\n\t\t\t\t\tAWSPinpointMessageEvent.MESSAGE_DISPLAYED\n\t\t\t\t);\n\t\t\t}, InAppMessageInteractionEvent.MESSAGE_DISPLAYED);\n\t\t\taddMessageInteractionEventListener((message: InAppMessage) => {\n\t\t\t\tthis.recordMessageEvent(\n\t\t\t\t\tmessage,\n\t\t\t\t\tAWSPinpointMessageEvent.MESSAGE_DISMISSED\n\t\t\t\t);\n\t\t\t}, InAppMessageInteractionEvent.MESSAGE_DISMISSED);\n\t\t\taddMessageInteractionEventListener((message: InAppMessage) => {\n\t\t\t\tthis.recordMessageEvent(\n\t\t\t\t\tmessage,\n\t\t\t\t\tAWSPinpointMessageEvent.MESSAGE_ACTION_TAKEN\n\t\t\t\t);\n\t\t\t}, InAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN);\n\t\t}\n\n\t\tthis.configured = true;\n\t\tdispatchInAppMessagingEvent('pinpointProvider_configured', null);\n\t\treturn this.config;\n\t};\n\n\tgetInAppMessages = async () => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\t// There is no way to granuarly reconcile the filter memoization as the keys are composited from a message id and\n\t\t// event properties thus opting to just clear them out when getting messages rather than leave potentially\n\t\t// obsolete entries that will no longer serve any purpose.\n\t\tclearMemo();\n\t\ttry {\n\t\t\tawait this.updateEndpoint();\n\t\t\tconst { appId, endpointId, pinpointClient } = this.config;\n\t\t\tconst input: GetInAppMessagesCommandInput = {\n\t\t\t\tApplicationId: appId,\n\t\t\t\tEndpointId: endpointId,\n\t\t\t};\n\t\t\tconst command: GetInAppMessagesCommand = new GetInAppMessagesCommand(\n\t\t\t\tinput\n\t\t\t);\n\t\t\tlogger.debug('getting in-app messages', input);\n\t\t\tconst response = await pinpointClient.send(command);\n\t\t\tconst { InAppMessageCampaigns: messages } =\n\t\t\t\tresponse.InAppMessagesResponse;\n\t\t\tdispatchInAppMessagingEvent('getInAppMessages', messages);\n\t\t\treturn messages;\n\t\t} catch (err) {\n\t\t\tlogger.error('Error getting in-app messages', err);\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\tprocessInAppMessages = async (\n\t\tmessages: any[],\n\t\tevent: InAppMessagingEvent\n\t): Promise<InAppMessage[]> => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\tlet highestPrioritySeen;\n\t\treturn this.normalizeMessages(\n\t\t\t(messages as PinpointInAppMessage[]).reduce((acc, message) => {\n\t\t\t\tconst messageQualifies =\n\t\t\t\t\tmatchesEventType(message, event) &&\n\t\t\t\t\tmatchesAttributes(message, event) &&\n\t\t\t\t\tmatchesMetrics(message, event) &&\n\t\t\t\t\tisBeforeEndDate(message) &&\n\t\t\t\t\tthis.isBelowCap(message);\n\t\t\t\t// filter all qualifying messages returning only those that are of (relative) highest priority\n\t\t\t\tif (messageQualifies) {\n\t\t\t\t\t// have not yet encountered message with priority\n\t\t\t\t\tif (!highestPrioritySeen) {\n\t\t\t\t\t\t// this message has priority, so reset the accumulator with this message only\n\t\t\t\t\t\tif (message.Priority) {\n\t\t\t\t\t\t\thighestPrioritySeen = message.Priority;\n\t\t\t\t\t\t\treturn [message];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// this message also has no priority, so just add this message to accumulator\n\t\t\t\t\t\t\tacc.push(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// have previously encountered message with priority, so only messages with priority matter now\n\t\t\t\t\t} else if (message.Priority) {\n\t\t\t\t\t\t// this message has higher priority (lower number), so reset the accumulator with this message only\n\t\t\t\t\t\tif (message.Priority < highestPrioritySeen) {\n\t\t\t\t\t\t\thighestPrioritySeen = message.Priority;\n\t\t\t\t\t\t\treturn [message];\n\t\t\t\t\t\t\t// this message has the same priority, so just add this message to accumulator\n\t\t\t\t\t\t} else if (message.Priority === highestPrioritySeen) {\n\t\t\t\t\t\t\tacc.push(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn acc;\n\t\t\t}, [])\n\t\t);\n\t};\n\n\tidentifyUser = async (userId: string, userInfo: UserInfo): Promise<void> => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\ttry {\n\t\t\tawait this.updateEndpoint(userId, userInfo);\n\t\t} catch (err) {\n\t\t\tlogger.error('Error identifying user', err);\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\tprivate init = async () => {\n\t\tconst { endpointId, storage } = this.config;\n\t\tconst providerName = this.getProviderName();\n\t\ttry {\n\t\t\t// Only run sync() if it's available (i.e. React Native)\n\t\t\tif (typeof storage.sync === 'function') {\n\t\t\t\tawait storage.sync();\n\t\t\t}\n\t\t\t// If an endpoint was not provided via configuration, try to get it from cache\n\t\t\tif (!endpointId) {\n\t\t\t\tthis.config.endpointId = await this.getEndpointId();\n\t\t\t}\n\t\t\tthis.initialized = true;\n\t\t} catch (err) {\n\t\t\tlogger.error(`Failed to initialize ${providerName}`, err);\n\t\t}\n\t};\n\n\tprivate initPinpointClient = async () => {\n\t\tconst { appId, credentials, pinpointClient, region } = this.config;\n\n\t\tif (!appId || !credentials || !region) {\n\t\t\tthrow new Error(\n\t\t\t\t'One or more of credentials, appId or region is not configured'\n\t\t\t);\n\t\t}\n\n\t\tif (pinpointClient) {\n\t\t\tpinpointClient.destroy();\n\t\t}\n\n\t\tthis.config.pinpointClient = new PinpointClient({\n\t\t\tregion,\n\t\t\tcredentials,\n\t\t\tcustomUserAgent: getAmplifyUserAgent(),\n\t\t});\n\t};\n\n\tprivate getEndpointId = async () => {\n\t\tconst { appId } = this.config;\n\t\t// Each Pinpoint channel requires its own Endpoint ID\n\t\tconst cacheKey = `${this.getSubCategory()}:${this.getProviderName()}:${appId}`;\n\t\t// First attempt to retrieve the ID from cache\n\t\tconst cachedEndpointId = await Cache.getItem(cacheKey);\n\t\t// Found in cache, just return it\n\t\tif (cachedEndpointId) {\n\t\t\treturn cachedEndpointId;\n\t\t}\n\t\t// Otherwise, generate a new ID and store it in long-lived cache before returning it\n\t\tconst endpointId = uuid();\n\t\t// Set a longer TTL to avoid endpoint id being deleted after the default TTL (3 days)\n\t\t// Also set its priority to the highest to reduce its chance of being deleted when cache is full\n\t\tconst ttl = 1000 * 60 * 60 * 24 * 365 * 100; // 100 years\n\t\tconst expiration = new Date().getTime() + ttl;\n\t\tCache.setItem(cacheKey, endpointId, {\n\t\t\texpires: expiration,\n\t\t\tpriority: 1,\n\t\t});\n\t\treturn endpointId;\n\t};\n\n\tprivate updateEndpoint = async (\n\t\tuserId: string = null,\n\t\tuserInfo: AWSPinpointUserInfo = null\n\t) => {\n\t\tconst {\n\t\t\tappId,\n\t\t\tcredentials,\n\t\t\tendpointId,\n\t\t\tendpointInfo = {},\n\t\t\tpinpointClient,\n\t\t} = this.config;\n\t\tconst currentCredentials = await this.getCredentials();\n\t\t// Shallow compare to determine if credentials stored here are outdated\n\t\tconst credentialsUpdated =\n\t\t\t!credentials ||\n\t\t\tObject.keys(currentCredentials).some(\n\t\t\t\tkey => currentCredentials[key] !== credentials[key]\n\t\t\t);\n\t\t// If endpoint is already initialized, and nothing else is changing, just early return\n\t\tif (\n\t\t\tthis.endpointInitialized &&\n\t\t\t!credentialsUpdated &&\n\t\t\t!userId &&\n\t\t\t!userInfo\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\t// Update credentials\n\t\tthis.config.credentials = currentCredentials;\n\t\ttry {\n\t\t\t// Initialize a new pinpoint client if one isn't already configured or if credentials changed\n\t\t\tif (!pinpointClient || credentialsUpdated) {\n\t\t\t\tawait this.initPinpointClient();\n\t\t\t}\n\t\t\tconst { address, attributes, demographic, location, metrics, optOut } =\n\t\t\t\tuserInfo ?? {};\n\t\t\tconst { appVersion, make, model, platform, version } = this.clientInfo;\n\t\t\t// Create the UpdateEndpoint input, prioritizing passed in user info and falling back to\n\t\t\t// defaults (if any) obtained from the config\n\t\t\tconst input: UpdateEndpointCommandInput = {\n\t\t\t\tApplicationId: appId,\n\t\t\t\tEndpointId: endpointId,\n\t\t\t\tEndpointRequest: {\n\t\t\t\t\tRequestId: uuid(),\n\t\t\t\t\tEffectiveDate: new Date().toISOString(),\n\t\t\t\t\tChannelType: ChannelType.IN_APP,\n\t\t\t\t\tAddress: address ?? endpointInfo.address,\n\t\t\t\t\tAttributes: {\n\t\t\t\t\t\t...endpointInfo.attributes,\n\t\t\t\t\t\t...attributes,\n\t\t\t\t\t},\n\t\t\t\t\tDemographic: {\n\t\t\t\t\t\tAppVersion: appVersion,\n\t\t\t\t\t\tMake: make,\n\t\t\t\t\t\tModel: model,\n\t\t\t\t\t\tModelVersion: version,\n\t\t\t\t\t\tPlatform: platform,\n\t\t\t\t\t\t...transferKeyToUpperCase({\n\t\t\t\t\t\t\t...endpointInfo.demographic,\n\t\t\t\t\t\t\t...demographic,\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t\tLocation: transferKeyToUpperCase({\n\t\t\t\t\t\t...endpointInfo.location,\n\t\t\t\t\t\t...location,\n\t\t\t\t\t}),\n\t\t\t\t\tMetrics: {\n\t\t\t\t\t\t...endpointInfo.metrics,\n\t\t\t\t\t\t...metrics,\n\t\t\t\t\t},\n\t\t\t\t\tOptOut: optOut ?? endpointInfo.optOut,\n\t\t\t\t\tUser: {\n\t\t\t\t\t\tUserId:\n\t\t\t\t\t\t\tuserId ?? endpointInfo.userId ?? currentCredentials.identityId,\n\t\t\t\t\t\tUserAttributes: attributes ?? endpointInfo.userAttributes,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst command: UpdateEndpointCommand = new UpdateEndpointCommand(input);\n\t\t\tlogger.debug('updating endpoint', input);\n\t\t\tawait this.config.pinpointClient.send(command);\n\t\t\tthis.endpointInitialized = true;\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\tprivate getCredentials = async () => {\n\t\ttry {\n\t\t\tconst credentials = await Credentials.get();\n\t\t\tif (!credentials) {\n\t\t\t\tlogger.debug('no credentials found');\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Credentials.shear(credentials);\n\t\t} catch (err) {\n\t\t\tlogger.error('Error getting credentials:', err);\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tprivate sessionStateChangeHandler: SessionStateChangeHandler = (\n\t\tstate: SessionState\n\t) => {\n\t\tif (state === 'started') {\n\t\t\t// reset all session counts\n\t\t\tthis.sessionMessageCountMap = {};\n\t\t}\n\t};\n\n\tprivate isBelowCap = ({\n\t\tCampaignId,\n\t\tSessionCap,\n\t\tDailyCap,\n\t\tTotalCap,\n\t}: PinpointInAppMessage): boolean => {\n\t\tconst { sessionCount, dailyCount, totalCount } =\n\t\t\tthis.getMessageCounts(CampaignId);\n\t\treturn (\n\t\t\t(!SessionCap || sessionCount < SessionCap) &&\n\t\t\t(!DailyCap || dailyCount < DailyCap) &&\n\t\t\t(!TotalCap || totalCount < TotalCap)\n\t\t);\n\t};\n\n\t// Use the current session count in memory or initialize as empty count\n\tprivate getSessionCount = (messageId: string): number =>\n\t\tthis.sessionMessageCountMap[messageId] || 0;\n\n\tprivate getDailyCount = (): number => {\n\t\tconst { storage } = this.config;\n\t\tconst today = getStartOfDay();\n\t\tconst item = storage.getItem(MESSAGE_DAILY_COUNT_KEY);\n\t\t// Parse stored count or initialize as empty count\n\t\tconst counter: DailyInAppMessageCounter = item\n\t\t\t? JSON.parse(item)\n\t\t\t: { count: 0, lastCountTimestamp: today };\n\t\t// If the stored counter timestamp is today, use it as the count, otherwise reset to 0\n\t\treturn counter.lastCountTimestamp === today ? counter.count : 0;\n\t};\n\n\tprivate getTotalCountMap = (): InAppMessageCountMap => {\n\t\tconst { storage } = this.config;\n\t\tconst item = storage.getItem(MESSAGE_TOTAL_COUNT_KEY);\n\t\t// Parse stored count map or initialize as empty\n\t\treturn item ? JSON.parse(item) : {};\n\t};\n\n\tprivate getTotalCount = (messageId: string): number => {\n\t\tconst countMap = this.getTotalCountMap();\n\t\t// Return stored count or initialize as empty count\n\t\treturn countMap[messageId] || 0;\n\t};\n\n\tprivate getMessageCounts = (messageId: string): InAppMessageCounts => {\n\t\ttry {\n\t\t\treturn {\n\t\t\t\tsessionCount: this.getSessionCount(messageId),\n\t\t\t\tdailyCount: this.getDailyCount(),\n\t\t\t\ttotalCount: this.getTotalCount(messageId),\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to get message counts from storage', err);\n\t\t}\n\t};\n\n\tprivate setSessionCount = (messageId: string, count: number): void => {\n\t\tthis.sessionMessageCountMap[messageId] = count;\n\t};\n\n\tprivate setDailyCount = (count: number): void => {\n\t\tconst { storage } = this.config;\n\t\tconst dailyCount: DailyInAppMessageCounter = {\n\t\t\tcount,\n\t\t\tlastCountTimestamp: getStartOfDay(),\n\t\t};\n\t\ttry {\n\t\t\tstorage.setItem(MESSAGE_DAILY_COUNT_KEY, JSON.stringify(dailyCount));\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to save daily message count to storage', err);\n\t\t}\n\t};\n\n\tprivate setTotalCountMap = (countMap: InAppMessageCountMap): void => {\n\t\tconst { storage } = this.config;\n\t\ttry {\n\t\t\tstorage.setItem(MESSAGE_TOTAL_COUNT_KEY, JSON.stringify(countMap));\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to save total count to storage', err);\n\t\t}\n\t};\n\n\tprivate setTotalCount = (messageId: string, count: number): void => {\n\t\tconst updatedMap = {\n\t\t\t...this.getTotalCountMap(),\n\t\t\t[messageId]: count,\n\t\t};\n\t\tthis.setTotalCountMap(updatedMap);\n\t};\n\n\tprivate incrementCounts = async (messageId: string): Promise<void> => {\n\t\tconst { sessionCount, dailyCount, totalCount } =\n\t\t\tthis.getMessageCounts(messageId);\n\t\tthis.setSessionCount(messageId, sessionCount + 1);\n\t\tthis.setDailyCount(dailyCount + 1);\n\t\tthis.setTotalCount(messageId, totalCount + 1);\n\t};\n\n\tprivate normalizeMessages = (\n\t\tmessages: PinpointInAppMessage[]\n\t): InAppMessage[] => {\n\t\treturn messages.map(message => {\n\t\t\tconst { CampaignId, InAppMessage } = message;\n\t\t\treturn {\n\t\t\t\tid: CampaignId,\n\t\t\t\tcontent: extractContent(message),\n\t\t\t\tlayout: interpretLayout(InAppMessage.Layout),\n\t\t\t\tmetadata: extractMetadata(message),\n\t\t\t};\n\t\t});\n\t};\n\n\tprivate recordMessageEvent = async (\n\t\tmessage: InAppMessage,\n\t\tevent: AWSPinpointMessageEvent\n\t): Promise<void> => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\trecordAnalyticsEvent(event, message);\n\t\tif (event === AWSPinpointMessageEvent.MESSAGE_DISPLAYED) {\n\t\t\tawait this.incrementCounts(message.id);\n\t\t}\n\t};\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}